Отличный список вопросов! Давайте разберем каждый, чтобы вы были готовы к экзамену.

**Теоретическая часть:**

---

**1. Недостатки плоских файлов и пути их преодоления.**

*   **Плоские файлы:** Данные хранятся в одном файле (или нескольких несвязанных), часто текстовом (например, CSV, TXT), где каждая строка представляет запись, а поля разделены разделителями или имеют фиксированную длину.
*   **Недостатки:**
    1.  **Избыточность данных (Data Redundancy):** Одна и та же информация может дублироваться в разных местах файла или в разных файлах. (Например, адрес клиента повторяется для каждого его заказа).
    2.  **Противоречивость данных (Data Inconsistency):** Из-за избыточности, при обновлении данных в одном месте, они могут остаться не обновленными в другом, что ведет к противоречиям.
    3.  **Трудности с доступом к данным:** Нет стандартизированного языка запросов. Для выборки данных нужно писать специальные программы, которые будут парсить файл. Сложные запросы реализовать очень трудно.
    4.  **Проблемы целостности данных (Data Integrity):** Сложно обеспечить соблюдение правил для данных (например, что возраст должен быть положительным числом, или что идентификатор клиента в заказе должен существовать в списке клиентов).
    5.  **Проблемы одновременного доступа (Concurrency Problems):** Несколько пользователей не могут эффективно работать с одним и тем же файлом одновременно без риска повреждения данных или конфликтов.
    6.  **Проблемы безопасности (Security Problems):** Сложно разграничить права доступа к разным частям данных для разных пользователей. Обычно доступ либо ко всему файлу, либо нет.
    7.  **Атомарность операций (Atomicity Problems):** Если операция состоит из нескольких шагов (например, перевод денег со счета на счет), и система падает посередине, данные могут остаться в несогласованном состоянии. Плоские файлы не поддерживают транзакции.
    8.  **Зависимость от приложения:** Структура данных в файле тесно связана с программой, которая его обрабатывает. Изменение структуры файла требует изменения программы.
*   **Пути преодоления:**
    *   **Использование Систем Управления Базами Данных (СУБД / DBMS):** СУБД предоставляют инструменты для:
        *   Структурированного хранения данных (модели данных).
        *   Устранения избыточности (через нормализацию в реляционных БД).
        *   Обеспечения целостности данных (через ограничения).
        *   Предоставления языка запросов (например, SQL).
        *   Управления одновременным доступом (механизмы блокировок, транзакции).
        *   Обеспечения безопасности (управление пользователями и правами).
        *   Обеспечения атомарности операций (транзакции).
        *   Независимости данных от приложений.

---

**2. Модели данных. Иерархическая, сетевая и реляционная модели данных.**

*   **Модель данных:** Концептуальный способ представления данных, их связей, семантики и ограничений целостности.
*   **Иерархическая модель:**
    *   **Структура:** Данные организованы в виде дерева. Есть корневая запись (родитель), которая может иметь несколько дочерних записей. Каждая дочерняя запись имеет только одного родителя.
    *   **Связи:** Строго "один-ко-многим" (1:N) между родителем и потомком.
    *   **Пример:** Файловая система, организационная структура предприятия.
    *   **Преимущества:** Простота для некоторых структур, быстрый доступ по иерархическим связям.
    *   **Недостатки:** Избыточность при представлении связей "многие-ко-многим" (M:N), сложность изменения структуры, сложные запросы вне иерархии.
*   **Сетевая модель:**
    *   **Структура:** Данные организованы в виде графа. Запись может иметь несколько родительских записей и несколько дочерних.
    *   **Связи:** Позволяет напрямую моделировать связи "многие-ко-многим" (M:N) через "наборы" (sets).
    *   **Пример:** Студенты и курсы (студент может посещать много курсов, курс может посещать много студентов).
    *   **Преимущества:** Эффективнее иерархической для M:N связей, уменьшение избыточности.
    *   **Недостатки:** Сложность проектирования и понимания, навигационный доступ к данным (нужно знать "путь"), зависимость приложений от физической структуры.
*   **Реляционная модель:**
    *   **Структура:** Данные представлены в виде таблиц (отношений). Таблица состоит из строк (кортежей) и столбцов (атрибутов).
    *   **Связи:** Устанавливаются через общие значения в столбцах (внешние ключи ссылаются на первичные ключи).
    *   **Пример:** Большинство современных СУБД (MySQL, PostgreSQL, Oracle, SQL Server).
    *   **Преимущества:** Гибкость, простота понимания, строгая математическая основа (реляционная алгебра, исчисление), независимость данных от приложений, мощный декларативный язык запросов (SQL).
    *   **Недостатки:** Может быть менее эффективной для некоторых специфических навигационных запросов по сравнению с иерархической/сетевой (хотя современные оптимизаторы и индексация решают эту проблему).

---




**3. Реляционная модель данных. 12 правил Кодда.**

*   **Реляционная модель данных:** (См. выше). Ключевые понятия: отношение (таблица), атрибут (столбец), кортеж (строка), домен (допустимые значения для атрибута), первичный ключ, внешний ключ.
*   **12 правил Кодда** (сформулированы Эдгаром Коддом для определения того, является ли СУБД полностью реляционной):
    1.  **Информационное правило:** Все данные в реляционной базе данных должны быть представлены явным образом на логическом уровне и только одним способом – значениями в таблицах.
    2.  **Правило гарантированного доступа:** Каждое значение данных в реляционной базе данных должно быть логически доступно путем указания имени таблицы, имени столбца и первичного ключа строки.
    3.  **Правило систематической обработки NULL-значений:** NULL-значения (отличные от пустой строки, пробелов, нуля и т.д.) должны поддерживаться для представления отсутствующей или неприменимой информации систематическим образом, независимо от типа данных.
    4.  **Правило динамического онлайн-каталога на основе реляционной модели:** Описание базы данных (метаданные) должно быть представлено на логическом уровне так же, как и обычные данные, чтобы авторизованные пользователи могли применять к нему тот же реляционный язык, который они применяют к обычным данным.
    5.  **Правило всеобъемлющего подъязыка данных:** Реляционная система должна поддерживать по крайней мере один реляционный язык, который:
        *   Имеет линейный синтаксис.
        *   Может использоваться как интерактивно, так и в прикладных программах.
        *   Поддерживает операции определения данных (включая определения представлений), операции манипулирования данными (включая выборку, вставку, обновление и удаление), ограничения целостности, авторизацию и операции управления транзакциями.
    6.  **Правило обновления представлений:** Все представления, которые теоретически обновляемы, должны быть обновляемы и системой.
    7.  **Правило высокоуровневых операций вставки, обновления и удаления:** Возможность обрабатывать базовое отношение или производное отношение как единый операнд должна применяться не только к выборке данных, но и к операциям вставки, обновления и удаления данных.
    8.  **Правило физической независимости данных:** Прикладные программы и терминальные операции не должны зависеть от того, как данные физически хранятся или извлекаются.
    9.  **Правило логической независимости данных:** Прикладные программы и терминальные операции не должны зависеть от изменений в логической структуре (таблиц), которые не затрагивают информацию, к которой они обращаются.
    10. **Правило независимости целостности:** Ограничения целостности, специфичные для конкретной реляционной базы данных, должны быть определены на реляционном языке данных и храниться в каталоге, а не в прикладных программах.
    11. **Правило независимости распределения:** База данных может быть распределена на несколько компьютеров, но это не должно быть видно пользователю, работающему с данными.
    12. **Правило единственного языка (Nonsubversion rule):** Если реляционная система имеет низкоуровневый язык (позволяющий обрабатывать одну запись за раз), то этот язык не должен использоваться для обхода правил целостности и ограничений, выраженных на высокоуровневом реляционном языке.



**Ключевая фраза (акростих):**
**"И** **Г**де **Н**аш **С**тарый **Я**ркий **П**лакат **М**ожет **Ф**изически **Л**ежать, **Ц**еликом **Р**аскидав **О**ковы?"**

Теперь расшифруем, привязывая к твоим пунктам:

1.  **И** (Информационное): **И**нформация вся в таблицах.
    *   *Твоё описание:* все данные хранятся только в виде значений в таблицах.
2.  **Г** (Гарантированное): **Г**арантированный доступ к данным (таблица, столбец, ключ).
    *   *Твоё описание:* к каждому значению можно обратиться, указав имя таблицы, столбца и значение ключа.
3.  **Н** (NULL): **Н**ет данных? Поддерживаем NULL! (или **Н**еопределенность)
    *   *Твоё описание:* Систематическая поддержка отсутствия значений (NULL).
4.  **С** (Схема): **С**ама база знает свою **С**хему (описание).
    *   *Твоё описание:* Онлайн-описание схемы: структура базы (схема) хранится в самой базе в виде специальных таблиц.
5.  **Я** (Язык): **Я**зык один для всего (SQL для всего).
    *   *Твоё описание:* Гарантированная поддержка языка манипулирования данными: наличие хотя бы одного языка (например, SQL) для всех операций.
6.  **П** (Представления): **П**редставления (view) обновляются.
    *   *Твоё описание:* Обновляемые представления: возможность обновлять данные через представления (view).
7.  **М** (Множества): **М**ощные операции над **М**ножествами строк.
    *   *Твоё описание:* Высокоуровневое добавление, обновление и удаление: поддержка операций сразу над множеством строк.
8.  **Ф** (Физическая): **Ф**изика хранения не волнует (физическая независимость).
    *   *Твоё описание:* Физическая независимость данных: изменение способа хранения не влияет на работу с данными.
9.  **Л** (Логическая): **Л**огика таблиц меняется, приложения не знают (логическая независимость).
    *   *Твоё описание:* Логическая независимость данных: изменение структуры таблиц не влияет на работу приложений.
10. **Ц** (Целостность): **Ц**елостность данных – забота базы, не приложений.
    *   *Твоё описание:* Независимость целостности: ограничения целостности определяются на уровне данных, а не приложений.
11. **Р** (Распределение): **Р**аспределение по сетям – не видно пользователю (или **Р**абота с распределенными как с обычными).
    *   *Твоё описание:* Независимость распределения: работа с распределёнными базами как с обычными.
12. **О** (Обход): **О**бходные пути? Только по правилам! (нет подрыва, **О**тсутствие подрыва).
    *   *Твоё описание:* Правило отсутствия подрывных подъязыков: если есть обходные пути, они должны подчиняться тем же правилам.

**Как это работает:**

1.  Запоминаешь фразу: **"И Где Наш Старый Яркий Плакат Может Физически Лежать, Целиком Раскидав Оковы?"**
2.  Каждое слово (или его первая буква) напоминает тебе ключевую идею правила.
3.  Произнося слово, ты вспоминаешь суть правила из твоей шпаргалки.

---

**4. Представление и манипулирование данными. Ограничения целостности. Каскадные операции.**

*   **Представление данных (в реляционной модели):**
    *   Данные хранятся в таблицах (отношениях).
    *   Каждая таблица имеет имя и состоит из столбцов (атрибутов) и строк (кортежей).
    *   Каждый столбец имеет имя и тип данных (домен).
    *   Каждая строка представляет одну сущность или связь.
    *   Порядок строк и столбцов (физический) не имеет значения для логического представления.
*   **Манипулирование данными:** Осуществляется с помощью языка манипулирования данными (DML), чаще всего SQL. Основные операции:
    *   `SELECT`: Извлечение данных.
    *   `INSERT`: Добавление новых данных (строк).
    *   `UPDATE`: Изменение существующих данных (строк).
    *   `DELETE`: Удаление данных (строк).
*   **Ограничения целостности:** Правила, обеспечивающие точность и согласованность данных.
    1.  **Целостность сущностей (Entity Integrity):** Первичный ключ таблицы не должен содержать NULL-значений и должен быть уникальным. Гарантирует, что каждая строка в таблице уникально идентифицируема. (Обеспечивается `PRIMARY KEY` и `NOT NULL`).
    2.  **Ссылочная целостность (Referential Integrity):** Если в таблице есть внешний ключ, то его значения должны либо соответствовать значениям первичного ключа в связанной (родительской) таблице, либо быть NULL (если разрешено). Гарантирует, что ссылки между таблицами корректны. (Обеспечивается `FOREIGN KEY`).
    3.  **Целостность доменов (Domain Integrity):** Значения в каждом столбце должны соответствовать определенному для него типу данных и формату, а также могут быть ограничены дополнительными правилами (например, `CHECK` constraint, `NOT NULL`).
    4.  **Пользовательские ограничения (User-defined Integrity):** Специфические бизнес-правила, которые не покрываются предыдущими типами (например, зарплата не может быть отрицательной – реализуется через `CHECK`, или более сложные правила через триггеры).
*   **Каскадные операции:** Действия, которые автоматически выполняются СУБД при изменении или удалении данных, на которые ссылаются другие данные (в контексте ссылочной целостности).
    *   `ON DELETE CASCADE`: Если удаляется строка в родительской таблице, то все связанные строки в дочерней таблице (ссылающиеся на удаленную строку через внешний ключ) также автоматически удаляются.
    *   `ON UPDATE CASCADE`: Если изменяется значение первичного ключа в родительской строке, то значения соответствующего внешнего ключа во всех связанных дочерних строках автоматически обновляются.
    *   Другие опции: `ON DELETE SET NULL`, `ON UPDATE SET NULL` (устанавливает внешний ключ в NULL), `ON DELETE RESTRICT`, `ON UPDATE RESTRICT` (запрещает операцию, если есть связанные строки), `ON DELETE NO ACTION`, `ON UPDATE NO ACTION` (аналогично RESTRICT, но проверка может быть отложена).

---

**5. Язык манипулирования для реляционной модели данных. Реляционная алгебра.**

*   **Язык манипулирования данными (DML):** Часть языка базы данных (например, SQL), используемая для выборки, вставки, обновления и удаления данных.
*   **Реляционная алгебра:**
    *   Формальный процедурный язык запросов для реляционной модели.
    *   Операндами являются отношения (таблицы).
    *   Результатом операции также является отношение (свойство замкнутости).
    *   Является теоретической основой для языков запросов, таких как SQL.
    *   **Основные операции:**
        1.  **Выборка (Selection, σ):** Выбирает строки (кортежи) из отношения, удовлетворяющие заданному условию (предикату). `σ_{условие}(R)`
        2.  **Проекция (Projection, π):** Выбирает указанные столбцы (атрибуты) из отношения, удаляя дубликаты строк в результате. `π_{атрибут1, атрибут2}(R)`
        3.  **Объединение (Union, ∪):** Формирует отношение, содержащее все кортежи, которые есть в первом отношении, во втором, или в обоих. Отношения должны быть совместимы по типам (одинаковое количество атрибутов и совместимые домены). Дубликаты удаляются. `R ∪ S`
        4.  **Разность (Set Difference, -):** Формирует отношение, содержащее все кортежи, которые есть в первом отношении, но отсутствуют во втором. Отношения должны быть совместимы по типам. `R - S`
        5.  **Декартово произведение (Cartesian Product, ×):** Формирует отношение, содержащее все возможные комбинации кортежей из двух отношений. `R × S`
        6.  **Переименование (Rename, ρ):** Изменяет имя отношения и/или его атрибутов. `ρ_{НовоеИмя(А1,А2..)}(R)`
    *   **Производные (дополнительные) операции:**
        1.  **Пересечение (Intersection, ∩):** Формирует отношение, содержащее только те кортежи, которые присутствуют в обоих отношениях. `R ∩ S` (Можно выразить как `R - (R - S)` или `S - (S - R)`).
        2.  **Соединение (Join, ⋈):** Комбинирует кортежи из двух отношений на основе некоторого условия сравнения значений их атрибутов.
            *   **Тета-соединение (Theta Join):** `R ⋈_{условие} S` (Общий случай, условие может быть любым сравнением).
            *   **Экви-соединение (Equijoin):** Частный случай тета-соединения, где условие – только равенство.
            *   **Естественное соединение (Natural Join):** Экви-соединение по всем одноименным атрибутам, при этом дублирующиеся столбцы удаляются. `R ⋈ S`
            *   **Внешние соединения (Outer Joins):** Left, Right, Full – включают строки, не имеющие соответствия в другой таблице, дополняя их NULL-значениями.
        3.  **Деление (Division, ÷):** Для отношений R(A,B) и S(B). Результат R ÷ S содержит те значения из A, которые в R связаны со *всеми* значениями B из S. Используется для запросов типа "найти всех, кто сделал *все*...".

---

**6. Реляционные операции и правила их выполнения.**

*   См. пункт 5 для описания операций.
*   **Правила выполнения (общие принципы):**
    1.  **Замкнутость:** Результатом любой операции реляционной алгебры всегда является отношение. Это позволяет применять операции последовательно (результат одной операции может быть входом для другой).
    2.  **Арность и совместимость:**
        *   Для унарных операций (выборка, проекция, переименование) операндом является одно отношение.
        *   Для бинарных операций (объединение, разность, декартово произведение, пересечение, соединение, деление) операндами являются два отношения.
        *   Операции объединения, разности, пересечения требуют **совместимости по типам (union compatibility)**: отношения должны иметь одинаковое количество атрибутов, и домены соответствующих атрибутов должны быть совместимы.
    3.  **Порядок кортежей и атрибутов:** В реляционной модели порядок кортежей в отношении и порядок атрибутов (логический) не имеет значения. Однако при выводе результата некоторые системы могут упорядочивать его.
    4.  **Дубликаты:** В теоретической реляционной алгебре отношения являются множествами кортежей, т.е. не содержат дубликатов. Операции проекции, объединения, разности, пересечения удаляют дубликаты. (В SQL `UNION ALL` сохраняет дубликаты).
    5.  **NULL-значения:** Обработка NULL-значений в условиях требует трехзначной логики (TRUE, FALSE, UNKNOWN). Обычно `σ` выбирает только те кортежи, для которых условие истинно (TRUE).
*   **Примеры выполнения:**
    *   `σ_{Зарплата > 50000}(Сотрудники)`: Выбирает всех сотрудников с зарплатой больше 50000.
    *   `π_{Имя, Фамилия}(Сотрудники)`: Выводит список имен и фамилий всех сотрудников (без дубликатов).
    *   `Программисты ∪ Тестировщики`: Выводит список всех сотрудников, являющихся либо программистами, либо тестировщиками.
    *   `Сотрудники ⋈_{Сотрудники.ОтделID = Отделы.ID} Отделы`: Соединяет таблицы Сотрудники и Отделы по идентификатору отдела.

---

**7. Типы запросов и их представление в реляционной алгебре.**

Любой запрос на выборку данных можно представить комбинацией операций реляционной алгебры.

*   **Простая выборка строк по условию:**
    *   Запрос: "Найти всех студентов с оценкой > 4 по предмету 'Базы данных'".
    *   РА: `σ_{(Предмет='Базы данных') ∧ (Оценка > 4)}(Оценки)`
*   **Проекция (выборка столбцов):**
    *   Запрос: "Показать имена и фамилии всех преподавателей".
    *   РА: `π_{Имя, Фамилия}(Преподаватели)`
*   **Комбинация выборки и проекции:**
    *   Запрос: "Показать имена студентов, сдавших экзамен на 'отлично'".
    *   РА: `π_{ИмяСтудента}(σ_{Оценка='отлично'}(РезультатыЭкзаменов))`
*   **Запросы с соединением таблиц:**
    *   Запрос: "Показать имена студентов и названия курсов, которые они посещают".
    *   РА: `π_{Студенты.Имя, Курсы.Название}(Студенты ⋈_{Студенты.ID = ЗаписиНаКурсы.СтудентID} ЗаписиНаКурсы ⋈_{ЗаписиНаКурсы.КурсID = Курсы.ID} Курсы)`
        (Или, если есть естественное соединение, то проще).
*   **Запросы с объединением:**
    *   Запрос: "Показать всех людей, которые являются либо студентами, либо преподавателями".
    *   РА: `π_{Имя}(Студенты) ∪ π_{Имя}(Преподаватели)` (при условии, что структура атрибута "Имя" совместима)
*   **Запросы с разностью:**
    *   Запрос: "Показать всех студентов, которые *не* записаны ни на один курс".
    *   РА: `π_{Имя}(Студенты) - π_{Имя}(π_{СтудентID}(ЗаписиНаКурсы) ⋈_{СтудентID=ID} Студенты)` (более сложный пример, может быть проще через другие подходы)
    *   Или: `π_{СтудентID}(Студенты) - π_{СтудентID}(ЗаписиНаКурсы)` (если нужны только ID).
*   **Запросы с декартовым произведением (редко используется напрямую, чаще как часть соединения):**
    *   Запрос: "Показать все возможные пары студент-преподаватель".
    *   РА: `Студенты × Преподаватели`
*   **Запросы с агрегацией (в чистой реляционной алгебре нет прямого аналога агрегатных функций SQL, но есть расширения):**
    *   Для агрегации часто используют оператор обобщенной проекции или группировки (`Ģ` или `γ`).
    *   Запрос: "Подсчитать количество студентов на каждом курсе".
    *   РА (с оператором группировки): `Ģ_{НазваниеКурса, COUNT(СтудентID) → КоличествоСтудентов} (Курсы ⋈ ЗаписиНаКурсы)`

---

**8. Свойства реляционных операций.**

Некоторые операции обладают алгебраическими свойствами, которые важны для оптимизации запросов:

*   **Коммутативность (перестановочность):**
    *   `R ∪ S = S ∪ R` (Объединение)
    *   `R ∩ S = S ∩ R` (Пересечение)
    *   `R × S = S × R` (Декартово произведение)
    *   `R ⋈ S = S ⋈ R` (Естественное соединение и экви-соединение)
    *   Выборка: `σ_{P1}(σ_{P2}(R)) = σ_{P2}(σ_{P1}(R)) = σ_{P1 ∧ P2}(R)` (Каскад выборок)
*   **Ассоциативность (сочетательность):**
    *   `(R ∪ S) ∪ T = R ∪ (S ∪ T)`
    *   `(R ∩ S) ∩ T = R ∩ (S ∩ T)`
    *   `(R × S) × T = R × (S × T)`
    *   `(R ⋈ S) ⋈ T = R ⋈ (S ⋈ T)` (Для соединений при определенных условиях)
*   **Дистрибутивность (распределительность):**
    *   Выборка дистрибутивна относительно `∪`, `∩`, `-`:
        *   `σ_{P}(R ∪ S) = σ_{P}(R) ∪ σ_{P}(S)`
        *   `σ_{P}(R - S) = σ_{P}(R) - σ_{P}(S)` (при условии, что P не ссылается на атрибуты S, не входящие в R)
    *   Проекция дистрибутивна относительно объединения:
        *   `π_{A}(R ∪ S) = π_{A}(R) ∪ π_{A}(S)`
    *   Соединение дистрибутивно относительно объединения (при определенных условиях):
        *   `R ⋈ (S ∪ T) = (R ⋈ S) ∪ (R ⋈ T)`
*   **Идемпотентность (повторное применение операции дает тот же результат):**
    *   `σ_{P}(σ_{P}(R)) = σ_{P}(R)`
    *   `π_{A}(π_{A}(R)) = π_{A}(R)`
*   **Каскадирование проекций:**
    *   Если A ⊆ B, то `π_{A}(π_{B}(R)) = π_{A}(R)`
*   **Перестановка проекции и выборки:**
    *   Если условие P использует только атрибуты из списка A, то `π_{A}(σ_{P}(R)) = σ_{P}(π_{A}(R))`
*   **Перестановка проекции и соединения:**
    *   Можно "протолкнуть" проекцию внутрь соединения, чтобы уменьшить размер промежуточных отношений, если атрибуты проекции и условия соединения это позволяют.
*   **Перестановка выборки и соединения:**
    *   Если условие P выборки относится только к атрибутам одного из отношений (например, R), то `σ_{P}(R ⋈ S) = (σ_{P}(R)) ⋈ S`
    *   Это очень важное свойство для оптимизации: выполнять выборку как можно раньше, чтобы уменьшить размер данных для последующих операций.

Эти свойства используются оптимизаторами запросов СУБД для преобразования исходного запроса (часто представленного в виде дерева операций) в эквивалентный, но более эффективный план выполнения.

---

**9. Проектирование реляционной базы данных с помощью нормализации.**

*   **Нормализация:** Процесс организации данных в базе данных с целью уменьшения избыточности данных и устранения аномалий (вставки, обновления, удаления). Это достигается путем декомпозиции (разделения) таблиц на меньшие, хорошо структурированные таблицы и определения связей между ними.
*   **Аномалии:**
    *   **Аномалия вставки:** Невозможность вставить данные об одной сущности без данных о другой. (Например, нельзя добавить новый курс, если на него еще не записан ни один студент, в таблице "Студент-Курс").
    *   **Аномалия обновления:** При изменении избыточных данных необходимо обновить их во всех местах, где они встречаются, иначе возникнет противоречивость.
    *   **Аномалия удаления:** Удаление данных об одной сущности может привести к непреднамеренной потере данных о другой. (Например, если студент был единственным на курсе, и его отчислили, информация о курсе может потеряться).
*   **Функциональная зависимость (ФЗ):** Атрибут Y функционально зависит от атрибута X (X → Y), если каждому значению X соответствует не более одного значения Y. X называется детерминантом, Y – зависимым атрибутом.
*   **Нормальные формы (НФ):**
    1.  **Первая нормальная форма (1НФ):**
        *   Все атрибуты атомарны (неделимы). Нет повторяющихся групп или многозначных атрибутов.
        *   Каждая ячейка таблицы содержит только одно значение.
        *   Есть первичный ключ.
    2.  **Вторая нормальная форма (2НФ):**
        *   Таблица находится в 1НФ.
        *   Все неключевые атрибуты полностью функционально зависят от *всего* первичного ключа. Нет частичных зависимостей (когда неключевой атрибут зависит только от части составного первичного ключа).
        *   Если первичный ключ простой (не составной), то таблица в 1НФ автоматически находится и в 2НФ.
        *   *Декомпозиция:* Если есть частичная зависимость `(PK_часть → Атрибут)`, то таблица разделяется на две: одна с `(PK_часть, Атрибут)` и другая с оставшимися атрибутами и полной зависимостью от полного PK.
    3.  **Третья нормальная форма (3НФ):**
        *   Таблица находится в 2НФ.
        *   Нет транзитивных зависимостей неключевых атрибутов от первичного ключа. То есть, неключевой атрибут не должен зависеть от другого неключевого атрибута. (Если `PK → НКА1` и `НКА1 → НКА2`, то это транзитивная зависимость `PK → НКА2` через `НКА1`).
        *   *Декомпозиция:* Если есть транзитивная зависимость `(НКА1 → НКА2)`, то `НКА2` выносится в отдельную таблицу вместе с `НКА1` (который становится PK новой таблицы), а `НКА1` остается в исходной как внешний ключ.
    4.  **Нормальная форма Бойса-Кодда (НФБК / BCNF):**
        *   Более строгая форма 3НФ.
        *   Таблица находится в НФБК, если для каждой нетривиальной функциональной зависимости X → Y, детерминант X является суперключом (кандидатным ключом).
        *   Отличие от 3НФ: 3НФ допускает, чтобы зависимый атрибут был частью кандидатного ключа, а в НФБК детерминант *обязан* быть суперключом.
        *   Чаще всего таблицы в 3НФ уже находятся и в НФБК. Проблемы возникают при наличии нескольких пересекающихся составных кандидатных ключей.
    *   **Другие НФ:** 4НФ (борется с многозначными зависимостями), 5НФ (борется с зависимостями соединения), ДКНФ (доменно-ключевая). На практике обычно достаточно 3НФ или НФБК.
*   **Процесс нормализации:**
    1.  Привести таблицу к 1НФ.
    2.  Определить все функциональные зависимости.
    3.  Привести к 2НФ, устранив частичные зависимости.
    4.  Привести к 3НФ, устранив транзитивные зависимости.
    5.  (При необходимости) Привести к НФБК.

---

**10. Язык SQL. Описание данных. Константы. Переменные. Функции. Выражения. Условия.**

*   **SQL (Structured Query Language):** Стандартный язык для работы с реляционными базами данных. Делится на несколько подъязыков:
    *   **DDL (Data Definition Language):** Язык определения данных. Используется для создания, изменения и удаления объектов базы данных (таблиц, индексов, представлений и т.д.). (См. вопрос 23)
    *   **DML (Data Manipulation Language):** Язык манипулирования данными. Используется для выборки, вставки, обновления и удаления данных. (См. вопрос 11)
    *   **DCL (Data Control Language):** Язык управления данными. Используется для управления правами доступа к данным (GRANT, REVOKE).
    *   **TCL (Transaction Control Language):** Язык управления транзакциями (BEGIN TRANSACTION, COMMIT, ROLLBACK). (См. вопрос 13)
*   **Описание данных (в SQL):** Используются операторы DDL: `CREATE TABLE`, `ALTER TABLE`, `DROP TABLE` для определения структуры таблиц, типов данных столбцов, ограничений.
    *   **Типы данных:** `INTEGER`, `VARCHAR(n)`, `CHAR(n)`, `DATE`, `TIMESTAMP`, `NUMERIC(p,s)`, `BOOLEAN`, `BLOB`, и т.д.
*   **Константы (литералы):** Фиксированные значения.
    *   **Числовые:** `10`, `3.14`, `-50`
    *   **Строковые:** `'Привет, мир!'` (в одинарных кавычках)
    *   **Даты/Время:** `'2023-10-27'`, `'2023-10-27 10:00:00'` (формат может зависеть от СУБД и настроек)
    *   **Булевы:** `TRUE`, `FALSE`
    *   **NULL:** Специальное значение, означающее отсутствие данных.
*   **Переменные:**
    *   В стандартном SQL нет явной поддержки переменных как в языках программирования.
    *   Однако, в диалектах SQL (PL/SQL, T-SQL, pgSQL) есть возможность объявлять и использовать переменные внутри блоков кода (хранимых процедур, функций, анонимных блоков).
    *   Пример T-SQL (SQL Server): `DECLARE @myVariable INT; SET @myVariable = 10; SELECT @myVariable;`
    *   Пример PL/pgSQL (PostgreSQL): `DO $$ DECLARE my_variable INTEGER; BEGIN my_variable := 10; RAISE NOTICE '%', my_variable; END $$;`
*   **Функции:**
    *   **Встроенные (системные):** Предоставляются СУБД.
        *   **Агрегатные:** `COUNT()`, `SUM()`, `AVG()`, `MIN()`, `MAX()` (работают с группами строк).
        *   **Скалярные:** Работают с одним значением и возвращают одно значение.
            *   **Строковые:** `UPPER()`, `LOWER()`, `SUBSTRING()`, `LENGTH()`, `CONCAT()`
            *   **Числовые:** `ABS()`, `ROUND()`, `FLOOR()`, `CEILING()`
            *   **Даты/времени:** `GETDATE()` (или `NOW()`), `DATEADD()`, `DATEDIFF()`, `YEAR()`, `MONTH()`, `DAY()`
            *   **Преобразования типов:** `CAST()`, `CONVERT()`
    *   **Пользовательские (UDF - User Defined Functions):** Создаются пользователями для выполнения специфических задач. Могут быть скалярными, табличными.
*   **Выражения:** Комбинации констант, переменных (в диалектах), имен столбцов, операторов и функций, которые вычисляются в одно значение.
    *   **Арифметические:** `Salary * 1.1`, `Quantity + 1`
    *   **Строковые:** `FirstName || ' ' || LastName` (оператор конкатенации `||` или `+` в T-SQL)
    *   **Логические:** `Age > 18 AND City = 'Москва'`
    *   **Вызовы функций:** `UPPER(ProductName)`
*   **Условия:** Логические выражения, которые оцениваются как TRUE, FALSE или UNKNOWN. Используются в:
    *   `WHERE` clause: для фильтрации строк.
    *   `HAVING` clause: для фильтрации групп.
    *   `ON` clause (в JOIN): для определения условия соединения.
    *   `CASE` expressions: для условного выбора значения.
    *   **Операторы в условиях:**
        *   Сравнения: `=`, `!=` (или `<>`), `<`, `>`, `<=`, `>=`
        *   Логические: `AND`, `OR`, `NOT`
        *   `BETWEEN ... AND ...`: Проверка на вхождение в диапазон.
        *   `IN (...)`: Проверка на вхождение в список значений.
        *   `LIKE`: Поиск по шаблону (с `%` - любая строка, `_` - любой символ).
        *   `IS NULL`, `IS NOT NULL`: Проверка на NULL.

---

**11. Язык SQL. Манипулирование данными.**

Это команды DML (Data Manipulation Language):

*   **`SELECT` (Выборка данных):**
    *   Извлекает данные из одной или нескольких таблиц.
    *   Синтаксис:
        ```sql
        SELECT column1, column2, ...
        FROM table_name
        [WHERE condition]
        [GROUP BY column_name(s)]
        [HAVING condition]
        [ORDER BY column_name(s) [ASC|DESC]];
        ```
    *   Пример: `SELECT ProductName, UnitPrice FROM Products WHERE CategoryID = 1 ORDER BY UnitPrice DESC;`

*   **`INSERT` (Вставка данных):**
    *   Добавляет одну или несколько новых строк в таблицу.
    *   Синтаксис:
        1.  Вставка с указанием столбцов:
            ```sql
            INSERT INTO table_name (column1, column2, ...)
            VALUES (value1, value2, ...);
            ```
        2.  Вставка без указания столбцов (значения должны соответствовать порядку столбцов в таблице):
            ```sql
            INSERT INTO table_name
            VALUES (value1, value2, ...);
            ```
        3.  Вставка результатов запроса SELECT:
            ```sql
            INSERT INTO table_name (column1, column2, ...)
            SELECT query_column1, query_column2, ...
            FROM another_table
            WHERE condition;
            ```
    *   Пример: `INSERT INTO Employees (FirstName, LastName, DepartmentID) VALUES ('Иван', 'Иванов', 3);`

*   **`UPDATE` (Обновление данных):**
    *   Изменяет существующие данные в одной или нескольких строках таблицы.
    *   Синтаксис:
        ```sql
        UPDATE table_name
        SET column1 = value1, column2 = value2, ...
        [WHERE condition];
        ```
    *   **Внимание:** Если `WHERE` отсутствует, будут обновлены **все** строки таблицы!
    *   Пример: `UPDATE Products SET UnitPrice = UnitPrice * 1.1 WHERE CategoryID = 2;`

*   **`DELETE` (Удаление данных):**
    *   Удаляет одну или несколько строк из таблицы.
    *   Синтаксис:
        ```sql
        DELETE FROM table_name
        [WHERE condition];
        ```
    *   **Внимание:** Если `WHERE` отсутствует, будут удалены **все** строки таблицы!
    *   Пример: `DELETE FROM Orders WHERE OrderDate < '2020-01-01';`

---

**12. Типы запросов и их представление в SQL.**

*   **Простая выборка всех данных из таблицы:**
    *   `SELECT * FROM Employees;`
*   **Выборка определенных столбцов (проекция):**
    *   `SELECT FirstName, LastName, Email FROM Customers;`
*   **Выборка с фильтрацией строк (условие WHERE):**
    *   `SELECT ProductName, UnitPrice FROM Products WHERE UnitPrice > 50;`
    *   `SELECT * FROM Orders WHERE OrderDate BETWEEN '2023-01-01' AND '2023-03-31' AND ShipCity = 'Москва';`
*   **Выборка с сортировкой (ORDER BY):**
    *   `SELECT ProductName, UnitPrice FROM Products ORDER BY UnitPrice DESC, ProductName ASC;`
*   **Выборка с удалением дубликатов (DISTINCT):**
    *   `SELECT DISTINCT City FROM Customers;`
*   **Выборка с ограничением количества строк (LIMIT / TOP):**
    *   SQL стандарт (PostgreSQL, MySQL): `SELECT * FROM Products ORDER BY UnitPrice DESC LIMIT 10;`
    *   SQL Server: `SELECT TOP 10 * FROM Products ORDER BY UnitPrice DESC;`
    *   Oracle (старый синтаксис): `SELECT * FROM (SELECT * FROM Products ORDER BY UnitPrice DESC) WHERE ROWNUM <= 10;`
    *   Oracle (новый синтаксис 12c+): `SELECT * FROM Products ORDER BY UnitPrice DESC FETCH FIRST 10 ROWS ONLY;`
*   **Агрегатные запросы (с GROUP BY и агрегатными функциями):**
    *   `SELECT DepartmentID, COUNT(*) AS NumberOfEmployees, AVG(Salary) AS AverageSalary FROM Employees GROUP BY DepartmentID;`
*   **Агрегатные запросы с фильтрацией групп (HAVING):**
    *   `SELECT DepartmentID, COUNT(*) AS NumberOfEmployees FROM Employees GROUP BY DepartmentID HAVING COUNT(*) > 10;`
*   **Запросы с соединениями таблиц (JOIN):**
    *   `INNER JOIN`: `SELECT o.OrderID, c.CustomerName FROM Orders o INNER JOIN Customers c ON o.CustomerID = c.CustomerID;`
    *   `LEFT JOIN`: `SELECT c.CustomerName, o.OrderID FROM Customers c LEFT JOIN Orders o ON c.CustomerID = o.CustomerID;`
    *   (Аналогично `RIGHT JOIN`, `FULL OUTER JOIN`)
*   **Запросы с псевдонимами (AS):**
    *   Для столбцов: `SELECT ProductName AS "Название товара", UnitPrice * 0.9 AS "Цена со скидкой" FROM Products;`
    *   Для таблиц (особенно полезно в JOIN'ах): `SELECT e.FirstName, d.DepartmentName FROM Employees e JOIN Departments d ON e.DepartmentID = d.DepartmentID;`
*   **Подзапросы (Subqueries):**
    *   В `WHERE`: `SELECT ProductName FROM Products WHERE CategoryID IN (SELECT CategoryID FROM Categories WHERE CategoryName = 'Напитки');`
    *   В `SELECT` (скалярный подзапрос): `SELECT ProductName, (SELECT COUNT(*) FROM OrderDetails od WHERE od.ProductID = p.ProductID) AS NumberOfOrders FROM Products p;`
    *   В `FROM` (производная таблица): `SELECT AvgSalaryDep.DepartmentName, AvgSalaryDep.AvgSal FROM (SELECT d.DepartmentName, AVG(e.Salary) AS AvgSal FROM Employees e JOIN Departments d ON e.DepartmentID = d.DepartmentID GROUP BY d.DepartmentName) AS AvgSalaryDep WHERE AvgSalaryDep.AvgSal > 60000;`
*   **Запросы с операциями над множествами (UNION, UNION ALL, INTERSECT, EXCEPT/MINUS):**
    *   `SELECT City FROM Customers UNION SELECT City FROM Suppliers;` (Уникальные города)
    *   `SELECT City FROM Customers UNION ALL SELECT City FROM Suppliers;` (Все города, с дубликатами)
    *   `SELECT City FROM Customers INTERSECT SELECT City FROM Suppliers;` (Города, где есть и клиенты, и поставщики)
    *   `SELECT City FROM Customers EXCEPT SELECT City FROM Suppliers;` (Города, где есть клиенты, но нет поставщиков. В Oracle `MINUS`)
*   **Запросы с использованием CASE (условные выражения):**
    *   ```sql
        SELECT OrderID, OrderDate,
               CASE
                   WHEN ShippedDate IS NULL THEN 'Not Shipped'
                   WHEN ShippedDate > RequiredDate THEN 'Shipped Late'
                   ELSE 'Shipped On Time'
               END AS ShippingStatus
        FROM Orders;
        ```

---

**13. Транзакции и их реализация в разных системах.**

*   **Транзакция:** Логическая единица работы, состоящая из одной или нескольких операций с базой данных, которая должна быть выполнена либо полностью (все операции успешно), либо не выполнена вовсе (если хотя бы одна операция неудачна, все предыдущие изменения отменяются).
*   **Свойства ACID (Атомарность, Согласованность, Изоляция, Долговечность):**
    1.  **Atomicity (Атомарность):** Транзакция выполняется как единое целое. Либо все её операции успешно завершаются (COMMIT), либо, если происходит сбой, ни одна из операций не оказывает влияния на базу данных (ROLLBACK).
    2.  **Consistency (Согласованность):** Транзакция переводит базу данных из одного согласованного состояния в другое согласованное состояние. Все ограничения целостности (PK, FK, CHECK) должны быть соблюдены по завершении транзакции.
    3.  **Isolation (Изоляция):** Параллельно выполняющиеся транзакции не должны влиять друг на друга. Результат выполнения набора параллельных транзакций должен быть таким же, как если бы они выполнялись последовательно в некотором порядке. (См. уровни изоляции).
    4.  **Durability (Долговечность):** Если транзакция успешно завершена (COMMIT), то её результаты должны быть сохранены постоянно и не должны быть потеряны даже в случае сбоев системы (например, отключение питания). Это достигается записью в журнал транзакций (transaction log).
*   **Команды SQL для управления транзакциями:**
    *   `BEGIN TRANSACTION` (или `START TRANSACTION` в некоторых СУБД): Начинает новую транзакцию.
    *   `COMMIT [TRANSACTION | WORK]`: Успешно завершает текущую транзакцию, делая все её изменения постоянными.
    *   `ROLLBACK [TRANSACTION | WORK]`: Отменяет все изменения, сделанные в текущей транзакции с момента её начала или с последнего SAVEPOINT.
    *   `SAVEPOINT savepoint_name`: Устанавливает точку сохранения внутри транзакции.
    *   `ROLLBACK TO SAVEPOINT savepoint_name`: Откатывает транзакцию до указанной точки сохранения, но не завершает транзакцию полностью.
*   **Реализация в разных системах (общие принципы):**
    1.  **Журналирование (Logging):**
        *   **Write-Ahead Logging (WAL):** Перед тем как изменения данных записываются на диск в основные файлы БД, информация об этих изменениях (логи) записывается в специальный журнал транзакций.
        *   Логи содержат информацию для отмены (undo) и повторного выполнения (redo) операций.
        *   Помогает обеспечить атомарность (откат по логам) и долговечность (восстановление после сбоя по логам).
    2.  **Блокировки (Locking):**
        *   Механизм для обеспечения изоляции. Когда транзакция обращается к данным (для чтения или изменения), она может наложить блокировку на эти данные (строку, страницу, таблицу).
        *   **Типы блокировок:** разделяемые (shared, S-lock) для чтения, эксклюзивные (exclusive, X-lock) для записи.
        *   Другие транзакции не могут получить конфликтующие блокировки на те же данные до тех пор, пока первая транзакция не снимет свою блокировку (обычно при COMMIT или ROLLBACK).
        *   Может приводить к **взаимоблокировкам (deadlocks)**, когда две или более транзакции ждут друг друга. СУБД обнаруживают и разрешают дедлоки (обычно откатывая одну из транзакций).
    3.  **Управление версиями (Multiversion Concurrency Control - MVCC):**
        *   Альтернатива или дополнение к блокировкам. Используется в PostgreSQL, Oracle, SQL Server (с определенными настройками).
        *   При изменении данных создается их новая версия, а старая версия сохраняется для транзакций, начавшихся до изменения.
        *   Читающие транзакции видят "снимок" данных на момент начала транзакции (или запроса), не блокируя пишущие транзакции, и наоборот ("читатели не блокируют писателей, писатели не блокируют читателей").
        *   Уменьшает конфликты блокировок, но требует больше дискового пространства и ресурсов для управления версиями.
    4.  **Уровни изоляции транзакций:** Определяют, какие аномалии параллельного доступа допустимы (для баланса между согласованностью и производительностью):
        *   `READ UNCOMMITTED`: Самый низкий. Разрешены "грязные чтения" (чтение не зафиксированных другой транзакцией данных).
        *   `READ COMMITTED`: Запрещены "грязные чтения". Транзакция видит только зафиксированные данные. Но возможны "неповторяемые чтения" и "фантомные чтения". (Часто уровень по умолчанию).
        *   `REPEATABLE READ`: Запрещены "грязные чтения" и "неповторяемые чтения" (повторное чтение тех же строк в рамках одной транзакции даст тот же результат). Но возможны "фантомные чтения".
        *   `SERIALIZABLE`: Самый высокий. Полная изоляция. Исключает все аномалии, как если бы транзакции выполнялись последовательно. Может снижать производительность из-за большего количества блокировок или других механизмов.
*   **Автофиксация (Autocommit):** В многих СУБД по умолчанию каждый SQL-оператор выполняется как отдельная транзакция и немедленно фиксируется. Для выполнения нескольких операций в одной транзакции нужно явно использовать `BEGIN TRANSACTION`.

---

**14. Динамический SQL и хранимые процедуры.**

*   **Динамический SQL:**
    *   SQL-запросы, которые конструируются и выполняются программой во время её работы (runtime), а не определены статически на этапе компиляции. Текст запроса часто формируется в виде строки, а затем передается СУБД для выполнения.
    *   **Применение:**
        *   Когда структура запроса (имена таблиц, столбцов, условия) неизвестна на этапе написания кода и определяется пользователем или другими условиями.
        *   Для утилит администрирования БД, генераторов отчетов.
    *   **Способы выполнения (зависят от СУБД и языка):**
        *   `EXECUTE IMMEDIATE 'SQL_QUERY_STRING'` (Oracle, DB2)
        *   `EXEC('SQL_QUERY_STRING')` или `sp_executesql N'SQL_QUERY_STRING'` (SQL Server)
        *   `PREPARE` и `EXECUTE` (многие СУБД, включая PostgreSQL, MySQL) - сначала подготавливается шаблон запроса с плейсхолдерами, затем выполняется с конкретными значениями.
    *   **Преимущества:**
        *   **Гибкость:** Позволяет строить очень гибкие запросы.
    *   **Недостатки:**
        *   **Риск SQL-инъекций:** Если строка запроса формируется путем конкатенации с пользовательским вводом без должной проверки и экранирования, это открывает уязвимость для SQL-инъекций. **Очень важно использовать параметризованные запросы или тщательно очищать ввод.**
        *   **Сложность отладки:** Ошибки в динамически сформированных запросах сложнее обнаружить.
        *   **Производительность:** Каждый раз запрос может парситься и оптимизироваться заново (хотя PREPARE/EXECUTE или кеширование планов могут помочь).
        *   **Права доступа:** Могут возникнуть проблемы с правами, если динамический SQL выполняется от имени пользователя с меньшими правами, чем у создателя контекста (например, процедуры).
*   **Хранимые процедуры (Stored Procedures):**
    *   Именованный блок кода (на SQL и/или процедурном расширении SQL, например, PL/SQL, T-SQL, PL/pgSQL), который хранится непосредственно в базе данных и может быть вызван по имени.
    *   Могут принимать входные параметры и возвращать выходные параметры или наборы результатов (result sets).
    *   **Преимущества:**
        1.  **Производительность:** Обычно компилируются один раз при создании и сохраняется план выполнения. Последующие вызовы выполняются быстрее, чем разбор и оптимизация "сырого" SQL каждый раз.
        2.  **Уменьшение сетевого трафика:** Вместо отправки длинных SQL-запросов клиент отправляет только имя процедуры и параметры.
        3.  **Повторное использование кода:** Логика инкапсулируется в процедуре и может вызываться из разных приложений или других процедур.
        4.  **Безопасность:** Можно предоставить пользователю права на выполнение процедуры, не давая прямых прав на таблицы, к которым процедура обращается (инкапсуляция прав).
        5.  **Централизация бизнес-логики:** Часть бизнес-логики можно реализовать на стороне БД, обеспечивая ее единообразие для всех клиентов.
        6.  **Поддержка транзакций:** Внутри процедуры можно управлять транзакциями.
    *   **Недостатки:**
        1.  **Переносимость:** Процедурные расширения SQL специфичны для каждой СУБД (T-SQL для SQL Server, PL/SQL для Oracle, PL/pgSQL для PostgreSQL). Перенос процедур между разными СУБД затруднен.
        2.  **Сложность отладки:** Отладка кода внутри БД может быть сложнее, чем отладка кода приложения.
        3.  **Нагрузка на сервер БД:** Если в процедурах реализуется сложная бизнес-логика, это увеличивает нагрузку на сервер БД.
        4.  **Версионирование и развертывание:** Управление версиями и развертывание изменений в хранимых процедурах требует отдельных процессов.
    *   **Пример (T-SQL для SQL Server):**
        ```sql
        CREATE PROCEDURE GetEmployeesByDepartment
            @DepartmentName NVARCHAR(50)
        AS
        BEGIN
            SELECT e.EmployeeID, e.FirstName, e.LastName, d.DepartmentName
            FROM Employees e
            JOIN Departments d ON e.DepartmentID = d.DepartmentID
            WHERE d.DepartmentName = @DepartmentName;
        END;
        GO
        -- Вызов:
        EXEC GetEmployeesByDepartment @DepartmentName = 'Sales';
        ```

**Связь:** Динамический SQL может использоваться *внутри* хранимых процедур, если логика процедуры требует построения запроса "на лету".

---

**15. Хранимые процедуры и триггеры.**

*   **Хранимые процедуры:** (См. вопрос 14)
    *   Вызываются явно по имени приложением или пользователем.
    *   Могут принимать параметры и возвращать результаты.
    *   Используются для инкапсуляции часто выполняемых операций, бизнес-логики.
*   **Триггеры (Triggers):**
    *   Особый тип хранимой процедуры, который **автоматически** выполняется (срабатывает) СУБД в ответ на определенные события (операции DML: `INSERT`, `UPDATE`, `DELETE`) с конкретной таблицей. Могут также срабатывать на события DDL (например, `CREATE TABLE`) или системные события (вход пользователя).
    *   **Не вызываются явно**, а "привязаны" к таблице и событию.
    *   **Типы триггеров по времени срабатывания:**
        *   `BEFORE` (ДО): Триггер срабатывает *перед* выполнением операции DML. Может использоваться для проверки или изменения данных *до* их записи.
        *   `AFTER` (ПОСЛЕ): Триггер срабатывает *после* успешного выполнения операции DML. Часто используется для аудита, каскадных обновлений в других таблицах.
        *   `INSTEAD OF` (ВМЕСТО): Специфический тип триггера (обычно для представлений - views), который выполняется *вместо* исходной операции DML. Позволяет определить собственную логику для обновления данных через представление, которое не является напрямую обновляемым.
    *   **Уровни срабатывания:**
        *   `FOR EACH ROW` (строковый): Триггер выполняется для каждой строки, затронутой операцией DML. Внутри такого триггера обычно доступны специальные псевдо-записи (например, `NEW` и `OLD` в PostgreSQL/Oracle, `inserted` и `deleted` в SQL Server) для доступа к новым и старым значениям изменяемой строки.
        *   `FOR EACH STATEMENT` (операторный): Триггер выполняется один раз для всего SQL-оператора, независимо от того, сколько строк он затрагивает.
    *   **Применение триггеров:**
        1.  **Обеспечение сложной целостности данных:** Реализация бизнес-правил, которые трудно или невозможно выразить через стандартные ограничения (constraints).
        2.  **Аудит (Logging):** Запись информации об изменениях данных в специальные таблицы аудита.
        3.  **Автоматическое обновление связанных данных (каскадные операции):** Например, при изменении статуса заказа обновить количество товара на складе.
        4.  **Генерация значений для столбцов:** Например, автоматическое заполнение поля `LastModifiedDate`.
        5.  **Предотвращение некорректных операций.**
    *   **Преимущества:**
        *   Автоматизация реакции на события.
        *   Обеспечение целостности и бизнес-правил на уровне БД.
    *   **Недостатки:**
        *   **Скрытая логика:** Действия триггеров не видны в SQL-запросе, который их вызвал. Это может затруднять понимание и отладку поведения системы ("магия").
        *   **Производительность:** Неаккуратно написанные триггеры могут серьезно замедлить операции DML.
        *   **Сложность:** Каскадные триггеры (один триггер вызывает операцию, которая запускает другой триггер и т.д.) могут быть очень сложны для анализа и отладки.
        *   **Порядок выполнения:** Если на одно событие определено несколько триггеров, их порядок выполнения может быть важен и не всегда очевиден или легко управляем (хотя СУБД предоставляют механизмы для этого).
    *   **Пример (PostgreSQL):**
        ```sql
        -- Функция, которую будет вызывать триггер
        CREATE FUNCTION update_last_modified_timestamp()
        RETURNS TRIGGER AS $$
        BEGIN
           NEW.last_modified = now(); -- NEW это специальная переменная для строки после изменения
           RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;

        -- Триггер
        CREATE TRIGGER products_last_modified_trigger
        BEFORE UPDATE ON products -- Срабатывает перед UPDATE на таблице products
        FOR EACH ROW -- Для каждой обновляемой строки
        EXECUTE FUNCTION update_last_modified_timestamp();
        ```

**Различия:**

| Признак            | Хранимая процедура                         | Триггер                                          |
| :----------------- | :----------------------------------------- | :----------------------------------------------- |
| **Вызов**          | Явный (по имени)                           | Неявный (автоматически при событии DML/DDL)      |
| **Параметры**      | Может принимать и возвращать параметры     | Обычно не принимает явных параметров (но имеет доступ к `NEW`/`OLD` или `inserted`/`deleted` таблицам) |
| **Возврат значения**| Может возвращать значения или наборы данных | Обычно не возвращает значения напрямую (но может изменять данные) |
| **Назначение**     | Инкапсуляция логики, повторное использование | Реакция на события, обеспечение целостности, аудит |
| **Привязка**       | Не привязана к таблице/событию             | Привязан к конкретной таблице и событию(-ям)      |

---

**16. Коллективный доступ к базе данных.**

*   **Коллективный (или параллельный/одновременный) доступ:** Ситуация, когда несколько пользователей или приложений одновременно обращаются к базе данных для чтения и/или изменения данных.
*   **Проблемы параллельного доступа (аномалии несогласованности):** Если не управлять параллельным доступом, могут возникнуть следующие проблемы:
    1.  **Потерянное обновление (Lost Update):** Две транзакции читают одни и те же данные, обе изменяют их и записывают обратно. Изменение, сделанное первой транзакцией, теряется, так как вторая транзакция перезаписывает его своим значением, не зная об изменении первой.
        *   Пример: T1 читает X=100, T2 читает X=100. T1 вычисляет X=100+10=110. T2 вычисляет X=100+20=120. T1 записывает X=110. T2 записывает X=120. Изменение T1 (+10) потеряно.
    2.  **"Грязное" чтение (Dirty Read):** Одна транзакция (T1) читает данные, измененные другой транзакцией (T2), которая еще не зафиксирована (не сделала COMMIT). Если T2 затем откатывается (ROLLBACK), то T1 прочитала "грязные", не существующие данные.
    3.  **Неповторяющееся чтение (Non-repeatable Read):** Транзакция (T1) читает одни и те же данные дважды, и между чтениями другая транзакция (T2) изменяет или удаляет эти данные и фиксирует изменения. В результате T1 получает разные значения при повторном чтении.
    4.  **Фантомное чтение (Phantom Read):** Транзакция (T1) выполняет запрос с некоторым условием выборки дважды. Между этими выполнениями другая транзакция (T2) вставляет новые строки (или удаляет строки), удовлетворяющие условию выборки T1, и фиксирует изменения. При повторном выполнении запроса T1 видит "фантомные" строки, которых не было раньше (или не видит строк, которые были).
*   **Механизмы управления параллельным доступом (Concurrency Control):**
    1.  **Блокировки (Locking):** (См. вопрос 13)
        *   **Пессимистические блокировки:** Транзакция блокирует ресурсы сразу, предполагая, что конфликт вероятен.
        *   **Уровни гранулярности блокировок:** Таблица, страница, строка. Чем мельче гранулярность, тем выше параллелизм, но больше накладных расходов на управление блокировками.
    2.  **Управление версиями (MVCC - Multiversion Concurrency Control):** (См. вопрос 13)
        *   **Оптимистический подход:** Транзакции работают с копиями (версиями) данных. Конфликты обнаруживаются на этапе фиксации. Если обнаружен конфликт, одна из транзакций откатывается.
    3.  **Временные метки (Timestamping):** Каждой транзакции присваивается уникальная временная метка при её старте. СУБД сравнивает метки транзакций, чтобы определить порядок их выполнения и разрешить конфликты. Если транзакция пытается прочитать или записать данные, которые были изменены более "молодой" транзакцией (с большей временной меткой), она может быть откатана.
    4.  **Уровни изоляции транзакций:** (См. вопрос 13 - READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE). Выбор уровня изоляции – это компромисс между степенью согласованности данных и производительностью/параллелизмом системы.
*   **Взаимоблокировки (Deadlocks):** Ситуация, когда две или более транзакции находятся в состоянии ожидания ресурсов, захваченных друг другом, и ни одна из них не может продолжаться.
    *   **Обнаружение дедлоков:** СУБД строит граф ожидания (wait-for graph). Если в графе есть цикл, значит, есть дедлок.
    *   **Разрешение дедлоков:** Обычно СУБД выбирает одну из транзакций ("жертву") и откатывает её, освобождая ресурсы и позволяя другим транзакциям продолжиться.

---

**17. Архитектура банков данных.**

Термин "банк данных" может трактоваться по-разному. Чаще всего он подразумевает **систему управления базами данных (СУБД)** и окружающую её инфраструктуру, или более широко – **информационную систему**, построенную на основе БД.

Рассмотрим несколько аспектов архитектуры:

*   **Трехуровневая архитектура ANSI-SPARC (см. вопрос 20):** Это фундаментальная концептуальная модель для СУБД.
    *   **Внешний уровень (External Level / View Level):** Представления данных для конкретных пользователей или приложений.
    *   **Концептуальный уровень (Conceptual Level / Logical Level):** Общее, единое описание всей базы данных (сущности, атрибуты, связи, ограничения).
    *   **Внутренний уровень (Internal Level / Physical Level):** Описание физического хранения данных (файлы, индексы, структуры данных).

*   **Компоненты типичной СУБД:**
    1.  **Процессор запросов (Query Processor):**
        *   **Парсер:** Проверяет синтаксис запроса.
        *   **Оптимизатор:** Анализирует запрос и генерирует наиболее эффективный план его выполнения.
        *   **Исполнитель запросов:** Выполняет план, обращаясь к менеджеру данных.
    2.  **Менеджер данных (Storage Manager / Data Manager):**
        *   **Менеджер буферов (Buffer Manager):** Управляет кэшированием данных в оперативной памяти (буферном пуле) для ускорения доступа.
        *   **Менеджер файлов (File Manager):** Отвечает за распределение пространства на диске и организацию данных в файлах.
        *   **Менеджер транзакций (Transaction Manager):** (См. вопрос 13) Координирует транзакции, обеспечивает ACID-свойства, управляет блокировками и журналированием.
        *   **Менеджер блокировок (Lock Manager):** Управляет блокировками ресурсов.
        *   **Менеджер журналов (Log Manager):** Отвечает за запись и чтение журнала транзакций.
    3.  **Утилиты:** Резервное копирование и восстановление, мониторинг, импорт/экспорт данных.
    4.  **Интерфейсы:** Для приложений (ODBC, JDBC, ADO.NET), для администраторов (консольные клиенты, GUI-инструменты).

*   **Архитектурные модели развертывания СУБД:**
    1.  **Централизованная:** Вся СУБД и данные находятся на одном мощном сервере. Клиенты подключаются к нему.
        *   Простота управления, но единая точка отказа и потенциальное "узкое место".
    2.  **Клиент-серверная:**
        *   **Двухуровневая (Two-tier):** Приложение-клиент напрямую подключается к серверу БД. Логика может быть на клиенте или в хранимых процедурах на сервере.
        *   **Трехуровневая/Многоуровневая (Three-tier/N-tier):** Между клиентом и сервером БД есть промежуточный слой – сервер приложений. Клиент взаимодействует с сервером приложений, а тот уже с сервером БД.
            *   Преимущества: лучшая масштабируемость, гибкость, безопасность, инкапсуляция бизнес-логики.
    3.  **Распределенная СУБД (Distributed DBMS):** База данных физически распределена по нескольким узлам (компьютерам), связанным сетью, но логически представляет собой единое целое.
        *   **Фрагментация данных:** Таблицы могут быть разделены (горизонтально или вертикально) и размещены на разных узлах.
        *   **Репликация данных:** Копии данных могут храниться на нескольких узлах для повышения доступности и производительности чтения.
        *   Сложность управления, обеспечения согласованности (например, двухфазный коммит для транзакций).
    4.  **Облачные СУБД (Cloud-based DBMS / DBaaS - Database as a Service):** СУБД предоставляется как сервис облачным провайдером (AWS RDS, Azure SQL Database, Google Cloud SQL).
        *   Преимущества: эластичность, управляемость, оплата по мере использования.

Если под "банком данных" подразумевается **хранилище данных (Data Warehouse)**, то архитектура будет включать:
*   **Источники данных:** Операционные системы (OLTP), внешние данные.
*   **ETL-процессы (Extract, Transform, Load):** Извлечение данных из источников, их преобразование (очистка, агрегация, интеграция) и загрузка в хранилище.
*   **Собственно хранилище данных (DWH):** Реляционная БД, оптимизированная для аналитических запросов (OLAP), часто использующая схемы "звезда" или "снежинка".
*   **Витрины данных (Data Marts):** Подмножества DWH, ориентированные на конкретные отделы или бизнес-задачи.
*   **Инструменты BI (Business Intelligence) и аналитики:** Для построения отчетов, дашбордов, выполнения OLAP-операций, data mining.

Для экзамена, скорее всего, ожидается понимание трехуровневой архитектуры ANSI-SPARC и основных компонентов СУБД.

---

**18. Использование внутреннего и внешнего соединения.**

**Соединения (JOINs)** в SQL используются для комбинирования строк из двух или более таблиц на основе связанного столбца между ними.

*   **Внутреннее соединение (INNER JOIN):**
    *   Возвращает только те строки, для которых существует совпадение в **обеих** таблицах на основе условия соединения. Если для строки из одной таблицы нет соответствующей строки в другой, эта строка не включается в результат.
    *   **Синтаксис:**
        ```sql
        SELECT t1.column_name, t2.column_name
        FROM table1 t1
        INNER JOIN table2 t2 ON t1.common_column = t2.common_column;
        ```
        (Ключевое слово `INNER` часто можно опустить, просто `JOIN` по умолчанию означает `INNER JOIN` в большинстве СУБД).
    *   **Пример:** Показать заказы и имена клиентов, их сделавших.
        ```sql
        SELECT o.OrderID, c.CustomerName
        FROM Orders o
        INNER JOIN Customers c ON o.CustomerID = c.CustomerID;
        -- Заказы без CustomerID или клиенты без заказов не попадут в результат.
        ```

*   **Внешние соединения (OUTER JOINs):**
    *   Возвращают строки даже если нет совпадения в одной из таблиц. Для несовпадающих строк столбцы из "недостающей" таблицы заполняются значениями `NULL`.
    1.  **Левое внешнее соединение (LEFT OUTER JOIN или просто LEFT JOIN):**
        *   Возвращает **все** строки из левой таблицы (указанной перед `LEFT JOIN`) и совпадающие строки из правой таблицы.
        *   Если для строки из левой таблицы нет совпадения в правой, столбцы правой таблицы в результате будут `NULL`.
        *   **Синтаксис:**
            ```sql
            SELECT t1.column_name, t2.column_name
            FROM table1 t1
            LEFT JOIN table2 t2 ON t1.common_column = t2.common_column;
            ```
        *   **Пример:** Показать всех клиентов и их заказы. Если у клиента нет заказов, он все равно будет в списке, но поля заказа будут `NULL`.
            ```sql
            SELECT c.CustomerName, o.OrderID, o.OrderDate
            FROM Customers c
            LEFT JOIN Orders o ON c.CustomerID = o.CustomerID;
            ```
    2.  **Правое внешнее соединение (RIGHT OUTER JOIN или просто RIGHT JOIN):**
        *   Возвращает **все** строки из правой таблицы (указанной после `RIGHT JOIN`) и совпадающие строки из левой таблицы.
        *   Если для строки из правой таблицы нет совпадения в левой, столбцы левой таблицы в результате будут `NULL`.
        *   **Синтаксис:**
            ```sql
            SELECT t1.column_name, t2.column_name
            FROM table1 t1
            RIGHT JOIN table2 t2 ON t1.common_column = t2.common_column;
            ```
        *   **Пример:** Показать все заказы и имена клиентов, которые их сделали. Если заказ существует, но по какой-то причине у него нет CustomerID или нет соответствующего клиента, заказ все равно будет в списке. (Менее часто используется, т.к. обычно можно переписать через `LEFT JOIN`, поменяв таблицы местами).
            ```sql
            SELECT c.CustomerName, o.OrderID, o.OrderDate
            FROM Customers c
            RIGHT JOIN Orders o ON c.CustomerID = o.CustomerID;
            ```
    3.  **Полное внешнее соединение (FULL OUTER JOIN или просто FULL JOIN):**
        *   Возвращает **все** строки из **обеих** таблиц.
        *   Если для строки из одной таблицы нет совпадения в другой, недостающие столбцы заполняются `NULL`.
        *   **Синтаксис:**
            ```sql
            SELECT t1.column_name, t2.column_name
            FROM table1 t1
            FULL OUTER JOIN table2 t2 ON t1.common_column = t2.common_column;
            ```
        *   **Пример:** Показать всех клиентов и все заказы. Если у клиента нет заказов, поля заказа будут `NULL`. Если у заказа нет клиента (что маловероятно при правильной БД), поля клиента будут `NULL`.
            ```sql
            SELECT c.CustomerName, o.OrderID
            FROM Customers c
            FULL OUTER JOIN Orders o ON c.CustomerID = o.CustomerID;
            ```

*   **Другие типы соединений (реже упоминаются в базовых курсах):**
    *   **CROSS JOIN (Декартово произведение):** Комбинирует каждую строку из первой таблицы с каждой строкой из второй таблицы. Условие `ON` не используется (или используется `ON 1=1`).
        `SELECT * FROM table1 CROSS JOIN table2;`
    *   **SELF JOIN (Самосоединение):** Таблица соединяется сама с собой. Используется, когда нужно сравнить строки внутри одной таблицы. Требует использования псевдонимов для таблицы.
        ```sql
        SELECT e1.EmployeeName, e2.EmployeeName AS ManagerName
        FROM Employees e1
        JOIN Employees e2 ON e1.ManagerID = e2.EmployeeID;
        -- Показать имя сотрудника и имя его руководителя.
        ```

**Когда что использовать:**
*   `INNER JOIN`: Когда нужны только те данные, которые имеют соответствие в обеих таблицах (например, "товары, которые были заказаны").
*   `LEFT JOIN`: Когда нужны все данные из левой таблицы, и опционально связанные данные из правой (например, "все клиенты и их заказы, если есть"). Это самый частый тип внешнего соединения.
*   `RIGHT JOIN`: Аналогично `LEFT JOIN`, но для правой таблицы. Часто можно избежать, переписав запрос с `LEFT JOIN`.
*   `FULL JOIN`: Когда нужны все данные из обеих таблиц, независимо от наличия совпадений (например, "сравнить два списка и показать все элементы из обоих, с указанием совпадений").

---

**19. Представления (view) и работа с ними.**

*   **Представление (View):**
    *   Виртуальная таблица, основанная на результате выполнения сохраненного SQL-запроса (`SELECT`).
    *   Само представление не хранит данные физически (за исключением материализованных представлений, что является отдельной темой). Оно хранит только определение запроса.
    *   Когда вы обращаетесь к представлению, СУБД выполняет этот сохраненный `SELECT`-запрос и возвращает результат, как если бы это была реальная таблица.
*   **Создание представления:**
    ```sql
    CREATE VIEW view_name AS
    SELECT column1, column2, ...
    FROM table_name(s)
    [WHERE condition]
    [GROUP BY ...]
    [HAVING ...];
    ```
    *   Пример: Представление, показывающее активных клиентов из Москвы.
        ```sql
        CREATE VIEW MoscowActiveCustomers AS
        SELECT CustomerID, CustomerName, Email, Phone
        FROM Customers
        WHERE City = 'Москва' AND IsActive = TRUE;
        ```
*   **Работа с представлениями:**
    *   **Запросы к представлениям:** Вы можете выполнять `SELECT`-запросы к представлению так же, как и к обычной таблице.
        ```sql
        SELECT CustomerName, Email FROM MoscowActiveCustomers WHERE CustomerName LIKE 'А%';
        ```
        СУБД фактически подставит определение `MoscowActiveCustomers` в этот запрос и оптимизирует его как единое целое.
    *   **Обновление данных через представления (DML операции - INSERT, UPDATE, DELETE):**
        *   Возможно, но с ограничениями. Представление должно быть "обновляемым".
        *   **Условия обновляемости (примерные, могут немного отличаться в разных СУБД):**
            1.  `SELECT` в определении представления должен ссылаться только на **одну** базовую таблицу. (Некоторые СУБД могут поддерживать обновление представлений на нескольких таблицах при определенных условиях).
            2.  Представление не должно использовать агрегатные функции (`COUNT`, `SUM`, `AVG` и т.д.).
            3.  Представление не должно использовать `GROUP BY` или `HAVING`.
            4.  Представление не должно использовать `DISTINCT`.
            5.  Представление не должно использовать подзапросы, которые ссылаются на ту же таблицу, что и внешний запрос (в некоторых случаях).
            6.  Все столбцы базовой таблицы, не имеющие значения по умолчанию и являющиеся `NOT NULL`, должны быть включены в представление, чтобы `INSERT` был возможен.
        *   Если представление обновляемо:
            ```sql
            UPDATE MoscowActiveCustomers
            SET Phone = '+79XXXXXXXXX'
            WHERE CustomerID = 123;
            -- Этот UPDATE фактически изменит данные в базовой таблице Customers.
            ```
        *   **`INSTEAD OF` триггеры:** Для представлений, которые не являются обновляемыми напрямую, можно определить `INSTEAD OF` триггеры. Эти триггеры будут выполняться *вместо* операции `INSERT`, `UPDATE` или `DELETE` на представлении, и в их теле можно написать логику для корректного изменения данных в базовых таблицах.
    *   **Изменение представления:**
        ```sql
        ALTER VIEW view_name AS
        SELECT ... ; -- новое определение
        ```
        (В некоторых СУБД может потребоваться `CREATE OR REPLACE VIEW ...`)
    *   **Удаление представления:**
        ```sql
        DROP VIEW view_name;
        -- Удаление представления не влияет на данные в базовых таблицах.
        ```
*   **Преимущества использования представлений:**
    1.  **Упрощение сложных запросов:** Скрыть сложную логику соединения нескольких таблиц, вычислений или фильтрации за простым именем представления.
    2.  **Безопасность данных:** Предоставить пользователям доступ только к определенным столбцам или строкам базовых таблиц, скрывая остальные. (Например, представление, не включающее столбец с зарплатой).
    3.  **Логическая независимость данных:** Если структура базовых таблиц меняется, но представление может быть изменено так, чтобы оно по-прежнему возвращало те же данные в том же формате, то приложения, использующие это представление, не потребуют изменений.
    4.  **Представление данных в удобном формате:** Можно объединять данные из разных таблиц, переименовывать столбцы, добавлять вычисляемые поля, чтобы представить данные в наиболее подходящем для пользователя виде.
    5.  **Согласованность:** Обеспечение того, чтобы все пользователи видели одни и те же агрегированные или вычисляемые значения, так как логика их расчета определена в одном месте.
*   **Недостатки/Особенности:**
    *   **Производительность:** Хотя СУБД пытаются оптимизировать запросы к представлениям, очень сложные представления или представления, построенные на других представлениях (вложенные представления), могут выполняться медленно.
    *   **Материализованные представления:** Это особый тип представлений, которые *хранят* результат своего запроса физически и периодически обновляются. Они могут значительно ускорить запросы, но требуют дискового пространства и накладных расходов на обновление. (Обычно это более продвинутая тема).

---

**20. Уровни представления данных (Трехуровневая модель представления данных.). Понятие схемы и подсхемы. Схема отношения.**

*   **Трехуровневая модель представления данных (ANSI-SPARC Architecture):**
    Стандартная архитектура для систем управления базами данных, предложенная комитетом ANSI/X3/SPARC в 1975 году. Она разделяет описание базы данных на три уровня абстракции, что обеспечивает независимость данных и гибкость.

    1.  **Внешний уровень (External Level или View Level):**
        *   Описывает, как видят базу данных **конкретные пользователи или группы пользователей/приложения**.
        *   Может существовать несколько различных внешних представлений для одной и той же базы данных.
        *   Каждое внешнее представление (или **подсхема**) включает только ту часть базы данных, которая интересна данному пользователю или приложению, и может представлять данные в удобном для них формате (например, через представления SQL `VIEW`).
        *   Обеспечивает логическую независимость данных для приложений (изменения в концептуальной схеме, не затрагивающие данное внешнее представление, не требуют изменения приложения).
        *   Позволяет скрыть детали всей БД и обеспечить безопасность.

    2.  **Концептуальный уровень (Conceptual Level или Logical Level):**
        *   Описывает **полную логическую структуру всей базы данных** для сообщества пользователей. Это "глобальный" взгляд на данные.
        *   Определяет все сущности, атрибуты, связи между ними, ограничения целостности, семантику данных.
        *   Независим от того, как данные физически хранятся (внутренний уровень) и как они видны конкретным пользователям (внешний уровень).
        *   Описание на этом уровне называется **концептуальной схемой** (или просто **схемой**).
        *   Обеспечивает физическую независимость данных (изменения в способе физического хранения не должны влиять на концептуальную схему).
        *   Разрабатывается администратором базы данных (DBA) и проектировщиками.

    3.  **Внутренний уровень (Internal Level или Physical Level):**
        *   Описывает, **как данные физически хранятся** на устройствах хранения (дисках).
        *   Определяет структуры данных (файлы, записи, блоки), пути доступа (индексы), методы сжатия, шифрования и т.д.
        *   Описание на этом уровне называется **внутренней схемой**.
        *   Связан с конкретной СУБД и операционной системой.
        *   Цель – эффективное использование пространства и быстрый доступ к данным.

    **Цели трехуровневой архитектуры:**
    *   **Независимость данных:**
        *   **Логическая независимость данных:** Возможность изменять концептуальную схему (например, добавлять новые таблицы или атрибуты) без необходимости изменять существующие внешние схемы или прикладные программы, которые не используют эти новые данные.
        *   **Физическая независимость данных:** Возможность изменять внутреннюю схему (например, изменять организацию файлов, добавлять индексы) без необходимости изменять концептуальную или внешние схемы.
    *   **Гибкость:** Легче адаптировать БД к меняющимся требованиям.
    *   **Управляемость:** Разделение задач проектирования и администрирования.

*   **Понятие схемы и подсхемы:**
    *   **Схема (Schema):** В контексте трехуровневой модели, "схема" чаще всего относится к **концептуальной схеме** – полному логическому описанию базы данных. В более общем смысле, схема – это формальное описание структуры данных (таблиц, столбцов, типов данных, связей, ограничений). В SQL, `CREATE SCHEMA` может создавать пространство имен для объектов БД.
    *   **Подсхема (Subschema):** Термин, используемый для описания **внешней схемы** – представления части базы данных для конкретного пользователя или приложения. Это подмножество концептуальной схемы, адаптированное для конкретных нужд. В SQL представления (`VIEW`) являются примером реализации подсхем.

*   **Схема отношения (Relation Schema):**
    *   В реляционной модели данных, схема отношения (или схема таблицы) – это **имя отношения (таблицы) вместе с набором его атрибутов (столбцов) и их доменов (типов данных)**.
    *   Пример: `Студенты (КодСтудента: INTEGER, Фамилия: VARCHAR(50), Имя: VARCHAR(50), ДатаРождения: DATE, ГруппаID: INTEGER)`
        Здесь:
        *   `Студенты` – имя отношения.
        *   `КодСтудента`, `Фамилия`, `Имя`, `ДатаРождения`, `ГруппаID` – имена атрибутов.
        *   `INTEGER`, `VARCHAR(50)`, `DATE` – домены (типы данных) атрибутов.
    *   Схема отношения определяет "шаблон" для кортежей (строк) этого отношения. Все кортежи в данном отношении должны соответствовать его схеме.

---

**21. Нотация Мартина. Нотация П.Чена.**

Это нотации, используемые для создания **ER-диаграмм (Entity-Relationship Diagrams)** – диаграмм "сущность-связь", которые являются инструментом концептуального проектирования баз данных.

*   **Нотация П. Чена (Peter Chen's Notation):**
    Одна из первых и классических нотаций.
    *   **Сущность (Entity):** Прямоугольник. Имя сущности пишется внутри.
        ```
        +-----------+
        |  Студент  |
        +-----------+
        ```
    *   **Атрибут (Attribute):** Овал, соединенный линией с сущностью или связью. Имя атрибута пишется внутри овала.
        *   **Ключевой атрибут (Primary Key):** Имя атрибута в овале подчеркивается.
        *   **Составной атрибут:** Овал, от которого отходят линии к другим овалам-компонентам.
        *   **Многозначный атрибут:** Двойной овал.
        *   **Производный атрибут:** Овал с пунктирной линией.
        ```
            (ФИО)
              |
        +-----------+--(ИД_Группы)
        |  Студент  |
        +-----------+
              |
            (<u>КодСтудента</u>)
        ```
    *   **Связь (Relationship):** Ромб, соединенный линиями с участвующими сущностями. Имя связи (обычно глагол) пишется внутри ромба.
        ```
        +-----------+     +-----------+     +---------+
        |  Студент  |-----|  Изучает  |-----|  Курс   |
        +-----------+     +-----------+     +---------+
        ```
    *   **Кардинальность связи (Cardinality):** Указывается на линиях, соединяющих сущности со связью. Обозначает, сколько экземпляров одной сущности может быть связано с экземплярами другой сущности.
        *   `1` (один)
        *   `M` или `N` (много)
        *   Пример: "Один преподаватель читает много курсов"
            ```
            +-------------+   1      N    +--------+
            | Преподаватель| -----<Читает>----- |  Курс  |
            +-------------+                  +--------+
            ```
        *   Могут быть также атрибуты у связей (если связь "многие-ко-многим").

*   **Нотация Мартина (James Martin's Notation / Information Engineering / Crow's Foot):**
    Более современная и часто используемая нотация, особенно в CASE-средствах.
    *   **Сущность (Entity):** Прямоугольник. Имя сущности пишется сверху или внутри. Атрибуты часто перечисляются внутри прямоугольника. Ключевые атрибуты помечаются (например, PK, подчеркиванием, или отделяются линией).
        ```
        +-------------------+
        | Студент (PK)      |
        +-------------------+
        | КодСтудента (PK)  |
        | ФИО               |
        | ИД_Группы (FK)    |
        +-------------------+
        ```
    *   **Связь (Relationship):** Линия между двумя сущностями. Имя связи может быть написано над/под линией.
    *   **Кардинальность (Cardinality) и Модальность (Optionality):** Отображаются специальными символами на концах линии связи, у каждой сущности.
        *   **Кардинальность ("куриная лапка" / crow's foot):**
            *   Одна черта (`|`) означает "один".
            *   "Куриная лапка" (`>-`) означает "много".
        *   **Модальность (обязательность участия в связи):**
            *   Кружок (`o`) означает "ноль" (необязательное участие, опционально).
            *   Черта (`|`) означает "один" (обязательное участие).
        *   **Комбинации:**
            *   `|-|` (один и только один, one-to-one mandatory)
            *   `|-o|` (один или ноль, one-to-one optional on the right side)
            *   `|->-` (один-ко-многим, обязательное "много")
            *   `o->-` (ноль-или-много, опциональное "много")
            *   `o-|-o` (ноль-или-один на обоих концах)
        *   **Пример:** "Один Отдел (обязательно) имеет много Сотрудников (ноль или много, т.е. в отделе может не быть сотрудников, или быть много; каждый сотрудник принадлежит одному отделу)".
            ```
            +---------+         +-------------+
            |  Отдел  | |-------o<| Сотрудник   |
            +---------+         +-------------+
            (один)               (ноль или много)
            ```
            *Надпись: Отдел содержит Сотрудников. Сотрудник работает в Отделе.*
            *Читается от сущности: Один `Отдел` связан с нулем или многими `Сотрудник`. Один `Сотрудник` связан с одним и только одним `Отдел`.*

**Ключевые отличия для запоминания:**

| Элемент        | Нотация Чена                                      | Нотация Мартина (Crow's Foot)                      |
| :------------- | :------------------------------------------------ | :------------------------------------------------- |
| **Сущность**   | Прямоугольник                                     | Прямоугольник (атрибуты часто внутри)              |
| **Атрибут**    | Овал (связан с сущностью)                         | Обычно перечисляется внутри прямоугольника сущности |
| **Связь**      | Ромб (между сущностями)                           | Линия между сущностями (имя связи над/под линией) |
| **Кардинальность**| Цифры/буквы (`1`, `N`, `M`) на линиях к ромбу связи | Графические символы ("куриная лапка", черта, кружок) на концах линии связи |

Обе нотации служат одной цели – визуализировать структуру данных и отношения между ними на концептуальном уровне. Выбор нотации часто зависит от предпочтений или используемых инструментов моделирования.

---

**22. Предложения SQL. Сортировка. Группировка. Условие в группировке. Функции;**

Это ключевые компоненты `SELECT` запроса в SQL, позволяющие обрабатывать и представлять данные.

*   **Сортировка (`ORDER BY`):**
    *   Используется для сортировки строк в результирующем наборе запроса.
    *   Размещается в конце `SELECT` запроса.
    *   Можно сортировать по одному или нескольким столбцам.
    *   Направление сортировки:
        *   `ASC` (Ascending) – по возрастанию (по умолчанию, если не указано).
        *   `DESC` (Descending) – по убыванию.
    *   **Синтаксис:**
        ```sql
        SELECT column1, column2, ...
        FROM table_name
        [WHERE condition]
        ORDER BY column_to_sort_by1 [ASC|DESC], column_to_sort_by2 [ASC|DESC], ...;
        ```
    *   **Пример:** Вывести список продуктов, отсортированных по убыванию цены, а при одинаковой цене – по названию в алфавитном порядке.
        ```sql
        SELECT ProductName, UnitPrice
        FROM Products
        ORDER BY UnitPrice DESC, ProductName ASC;
        ```
    *   Можно сортировать по псевдонимам столбцов или по номеру столбца в `SELECT` (хотя последнее менее читаемо и не рекомендуется для поддержки кода).

*   **Группировка (`GROUP BY`):**
    *   Используется для объединения строк с одинаковыми значениями в одном или нескольких столбцах в одну сводную строку.
    *   Часто используется вместе с **агрегатными функциями** для вычисления итоговых значений для каждой группы.
    *   Все столбцы в `SELECT` списке, которые не являются агрегатными функциями, **должны** быть включены в `GROUP BY` предложение.
    *   **Синтаксис:**
        ```sql
        SELECT column_to_group_by, AGGREGATE_FUNCTION(column_to_aggregate)
        FROM table_name
        [WHERE condition] -- Фильтрует строки ДО группировки
        GROUP BY column_to_group_by
        [HAVING condition]; -- Фильтрует группы ПОСЛЕ группировки
        ```
    *   **Пример:** Подсчитать количество заказов для каждого клиента.
        ```sql
        SELECT CustomerID, COUNT(OrderID) AS NumberOfOrders
        FROM Orders
        GROUP BY CustomerID;
        ```

*   **Агрегатные Функции (используются с `GROUP BY` или без него для всей таблицы):**
    *   `COUNT(*)`: Количество строк в группе (или во всей таблице).
    *   `COUNT(column_name)`: Количество не-NULL значений в указанном столбце в группе.
    *   `COUNT(DISTINCT column_name)`: Количество уникальных не-NULL значений.
    *   `SUM(column_name)`: Сумма значений в столбце для группы.
    *   `AVG(column_name)`: Среднее значение в столбце для группы.
    *   `MIN(column_name)`: Минимальное значение в столбце для группы.
    *   `MAX(column_name)`: Максимальное значение в столбце для группы.
    *   **Пример (без `GROUP BY`):** Общее количество продуктов и средняя цена.
        ```sql
        SELECT COUNT(*) AS TotalProducts, AVG(UnitPrice) AS AveragePrice
        FROM Products;
        ```

*   **Условие в группировке (`HAVING`):**
    *   Используется для фильтрации групп, созданных предложением `GROUP BY`.
    *   Аналогично `WHERE`, но `WHERE` фильтрует строки **до** того, как они группируются, а `HAVING` фильтрует **группы** после их формирования.
    *   В предложении `HAVING` можно использовать агрегатные функции, в `WHERE` – нельзя (потому что `WHERE` работает до агрегации).
    *   **Синтаксис:** (см. выше в `GROUP BY`)
    *   **Пример:** Найти клиентов, сделавших более 5 заказов, и показать количество их заказов.
        ```sql
        SELECT CustomerID, COUNT(OrderID) AS NumberOfOrders
        FROM Orders
        GROUP BY CustomerID
        HAVING COUNT(OrderID) > 5;
        ```
        Здесь:
        1.  `GROUP BY CustomerID` группирует заказы по клиентам.
        2.  `COUNT(OrderID)` подсчитывает заказы для каждой группы (для каждого клиента).
        3.  `HAVING COUNT(OrderID) > 5` отбирает только те группы (тех клиентов), у которых количество заказов больше 5.

*   **Порядок выполнения логических частей `SELECT` запроса:**
    1.  `FROM` (и `JOIN`s) – определяются исходные таблицы.
    2.  `WHERE` – фильтруются строки.
    3.  `GROUP BY` – строки группируются.
    4.  `HAVING` – фильтруются группы.
    5.  `SELECT` – выбираются столбцы и вычисляются выражения/функции.
    6.  `DISTINCT` – удаляются дубликаты (если указано).
    7.  `ORDER BY` – результат сортируется.
    8.  `LIMIT` / `OFFSET` (или `TOP`) – ограничивается количество выводимых строк.

    Знание этого порядка важно для понимания, почему, например, нельзя использовать псевдоним столбца из `SELECT` в `WHERE` (он еще не определен), но можно в `ORDER BY` (он уже определен).

---

**23. Язык определения данных. Предложения CREATE, ALTER, DROP. Приведите пример использования каждого предложения;**

**DDL (Data Definition Language)** – это подмножество SQL, используемое для определения и управления структурой объектов базы данных. Основные команды DDL: `CREATE`, `ALTER`, `DROP`.

*   **`CREATE` (Создать):**
    Используется для создания новых объектов в базе данных.
    *   **`CREATE DATABASE database_name;`**
        *   Создает новую базу данных.
        *   Пример:
            ```sql
            CREATE DATABASE MyCompanyDB;
            ```
    *   **`CREATE TABLE table_name (column_definitions, [constraints]);`**
        *   Создает новую таблицу. `column_definitions` включают имя столбца, тип данных и необязательные ограничения для столбца. `constraints` могут быть ограничениями на уровне таблицы.
        *   Пример:
            ```sql
            CREATE TABLE Employees (
                EmployeeID INT PRIMARY KEY,         -- Первичный ключ
                FirstName VARCHAR(50) NOT NULL,   -- Не может быть NULL
                LastName VARCHAR(50) NOT NULL,
                Email VARCHAR(100) UNIQUE,        -- Уникальное значение
                HireDate DATE DEFAULT GETDATE(),  -- Значение по умолчанию (синтаксис GETDATE() для SQL Server, NOW() для PostgreSQL/MySQL)
                Salary DECIMAL(10, 2) CHECK (Salary > 0), -- Проверка значения
                DepartmentID INT,
                CONSTRAINT FK_Employees_Departments FOREIGN KEY (DepartmentID) -- Внешний ключ
                    REFERENCES Departments(DepartmentID)
                    ON DELETE SET NULL  -- Пример каскадной операции
                    ON UPDATE CASCADE
            );
            ```
    *   **`CREATE INDEX index_name ON table_name (column_list);`**
        *   Создает индекс для одного или нескольких столбцов таблицы для ускорения поиска.
        *   Пример:
            ```sql
            CREATE INDEX IX_Employees_LastName ON Employees (LastName);
            ```
    *   **`CREATE VIEW view_name AS SELECT_statement;`**
        *   Создает представление (виртуальную таблицу). (См. вопрос 19)
        *   Пример:
            ```sql
            CREATE VIEW EmployeeSalaries AS
            SELECT EmployeeID, FirstName, LastName, Salary
            FROM Employees
            WHERE Salary > 50000;
            ```
    *   (Также `CREATE SCHEMA`, `CREATE SEQUENCE`, `CREATE FUNCTION`, `CREATE PROCEDURE`, `CREATE TRIGGER` и др.)

*   **`ALTER` (Изменить):**
    Используется для изменения структуры существующих объектов базы данных.
    *   **`ALTER TABLE table_name action;`**
        *   Изменяет структуру таблицы. `action` может быть:
            *   `ADD COLUMN column_definition`: Добавить новый столбец.
            *   `DROP COLUMN column_name`: Удалить столбец.
            *   `ALTER COLUMN column_name new_type_or_properties` или `MODIFY COLUMN column_name new_type_or_properties`: Изменить тип данных или свойства столбца (синтаксис может отличаться в разных СУБД).
            *   `ADD CONSTRAINT constraint_definition`: Добавить ограничение.
            *   `DROP CONSTRAINT constraint_name`: Удалить ограничение.
            *   `RENAME TO new_table_name`: Переименовать таблицу (в некоторых СУБД).
            *   `RENAME COLUMN old_column_name TO new_column_name`: Переименовать столбец (в некоторых СУБД).
        *   Примеры:
            ```sql
            -- Добавить столбец
            ALTER TABLE Employees
            ADD PhoneNumber VARCHAR(20);

            -- Изменить тип данных столбца (SQL Server)
            ALTER TABLE Employees
            ALTER COLUMN PhoneNumber VARCHAR(25);

            -- Изменить тип данных столбца (MySQL/PostgreSQL)
            -- ALTER TABLE Employees
            -- MODIFY COLUMN PhoneNumber VARCHAR(25); -- MySQL
            -- ALTER TABLE Employees
            -- ALTER COLUMN PhoneNumber TYPE VARCHAR(25); -- PostgreSQL

            -- Добавить ограничение UNIQUE
            ALTER TABLE Employees
            ADD CONSTRAINT UQ_Employees_PhoneNumber UNIQUE (PhoneNumber);

            -- Удалить столбец
            ALTER TABLE Employees
            DROP COLUMN HireDate;
            ```
    *   (Также `ALTER DATABASE`, `ALTER INDEX`, `ALTER VIEW`, `ALTER FUNCTION`, `ALTER PROCEDURE`, `ALTER TRIGGER` и др.)

*   **`DROP` (Удалить):**
    Используется для полного удаления объектов из базы данных. **Эта операция необратима!**
    *   **`DROP DATABASE database_name;`**
        *   Удаляет базу данных со всеми ее объектами.
        *   Пример:
            ```sql
            DROP DATABASE MyCompanyDB;
            ```
    *   **`DROP TABLE table_name;`**
        *   Удаляет таблицу и все ее данные, индексы, триггеры и ограничения, связанные с ней.
        *   Пример:
            ```sql
            DROP TABLE Employees;
            ```
    *   **`DROP INDEX index_name ON table_name;`** (Синтаксис может немного отличаться: `DROP INDEX index_name;` в MySQL)
        *   Удаляет индекс.
        *   Пример:
            ```sql
            DROP INDEX IX_Employees_LastName ON Employees;
            ```
    *   **`DROP VIEW view_name;`**
        *   Удаляет представление.
        *   Пример:
            ```sql
            DROP VIEW EmployeeSalaries;
            ```
    *   (Также `DROP SCHEMA`, `DROP SEQUENCE`, `DROP FUNCTION`, `DROP PROCEDURE`, `DROP TRIGGER` и др.)

**Важно:**
*   Перед выполнением `DROP` убедитесь, что вы удаляете правильный объект, так как данные будут потеряны.
*   Некоторые `DROP` операции могут не выполниться, если на удаляемый объект есть ссылки (например, нельзя удалить таблицу, на которую ссылается внешний ключ из другой таблицы, если не указано `CASCADE` или если сначала не удалить зависимые объекты/ограничения).
*   Синтаксис некоторых `ALTER` команд (особенно `ALTER COLUMN`) может варьироваться между различными СУБД (SQL Server, Oracle, MySQL, PostgreSQL).

---

**24. Предложения SQL. Выборка. Виды выборки. Псевдонимы. Условия**

Это углубление в оператор `SELECT`.

*   **`SELECT` (Выборка):**
    Основной оператор DML для извлечения данных из базы данных. (Уже подробно рассмотрен в вопросах 11, 12, 22).
    Базовая структура:
    ```sql
    SELECT [DISTINCT] select_list /* что выбираем */
    FROM table_references   /* откуда выбираем */
    [WHERE search_condition] /* фильтрация строк */
    [GROUP BY group_by_list] /* группировка строк */
    [HAVING search_condition] /* фильтрация групп */
    [ORDER BY order_by_list]; /* сортировка результата */
    ```

*   **Виды выборки (в зависимости от используемых предложений и цели):**
    1.  **Выборка всех столбцов и всех строк:**
        ```sql
        SELECT * FROM Employees;
        ```
    2.  **Выборка определенных столбцов (проекция):**
        ```sql
        SELECT FirstName, LastName, Email FROM Employees;
        ```
    3.  **Выборка с условием (фильтрация строк) (`WHERE`):**
        ```sql
        SELECT ProductName, UnitPrice FROM Products WHERE CategoryID = 1 AND UnitPrice > 20;
        ```
    4.  **Выборка с удалением дубликатов (`DISTINCT`):**
        Показывает только уникальные комбинации значений выбранных столбцов.
        ```sql
        SELECT DISTINCT City FROM Customers;
        ```
    5.  **Выборка с вычисляемыми полями:**
        Можно использовать выражения и функции в списке `SELECT`.
        ```sql
        SELECT ProductName, UnitPrice, UnitPrice * 0.1 AS DiscountAmount, UnitPrice * 0.9 AS DiscountedPrice
        FROM Products;
        ```
    6.  **Выборка с агрегацией (`GROUP BY`, агрегатные функции):**
        Для получения итоговых данных по группам.
        ```sql
        SELECT DepartmentID, AVG(Salary) AS AverageSalary
        FROM Employees
        GROUP BY DepartmentID;
        ```
    7.  **Выборка из нескольких таблиц (соединения `JOIN`):**
        Для комбинирования данных из связанных таблиц.
        ```sql
        SELECT e.FirstName, e.LastName, d.DepartmentName
        FROM Employees e
        INNER JOIN Departments d ON e.DepartmentID = d.DepartmentID;
        ```
    8.  **Выборка с использованием подзапросов (Subqueries):**
        Запросы, вложенные в другие запросы.
        ```sql
        SELECT ProductName
        FROM Products
        WHERE CategoryID = (SELECT CategoryID FROM Categories WHERE CategoryName = 'Beverages');
        ```
    9.  **Выборка с операциями над множествами (`UNION`, `INTERSECT`, `EXCEPT`):**
        Для объединения, пересечения или вычитания результатов двух или более запросов.
        ```sql
        SELECT City FROM Customers
        UNION
        SELECT City FROM Suppliers;
        ```
    10. **Выборка с сортировкой (`ORDER BY`):**
        Для упорядочивания результата.
        ```sql
        SELECT ProductName, UnitPrice FROM Products ORDER BY UnitPrice DESC;
        ```
    11. **Выборка с ограничением количества строк (`LIMIT`, `TOP`):**
        Для получения части результата (например, первых N строк).
        ```sql
        SELECT ProductName, UnitPrice FROM Products ORDER BY UnitPrice DESC LIMIT 5; -- (PostgreSQL/MySQL)
        -- SELECT TOP 5 ProductName, UnitPrice FROM Products ORDER BY UnitPrice DESC; -- (SQL Server)
        ```

*   **Псевдонимы (Aliases):**
    Временные имена, присваиваемые таблицам или столбцам в рамках одного SQL-запроса. Используются для:
    *   Улучшения читаемости запроса.
    *   Сокращения длинных имен таблиц/столбцов.
    *   Различения столбцов с одинаковыми именами из разных таблиц при соединениях.
    *   Присвоения имени вычисляемому полю или результату функции.
    *   При самосоединении таблицы (self-join).
    *   **Псевдонимы столбцов:**
        Задаются с помощью ключевого слова `AS` (можно опустить) после выражения столбца.
        ```sql
        SELECT FirstName AS Name, LastName AS Surname, Salary * 12 AS AnnualSalary
        FROM Employees;
        -- или
        SELECT FirstName Name, LastName Surname, Salary * 12 AnnualSalary
        FROM Employees;
        ```
        Если псевдоним содержит пробелы или специальные символы, или является зарезервированным словом, его нужно заключить в двойные кавычки (стандарт SQL, PostgreSQL, Oracle) или квадратные скобки (SQL Server).
        `SELECT Salary * 0.1 AS "Tax Amount"`
    *   **Псевдонимы таблиц:**
        Задаются после имени таблицы (ключевое слово `AS` обычно опускается для псевдонимов таблиц).
        ```sql
        SELECT e.FirstName, e.LastName, d.DepartmentName
        FROM Employees e -- 'e' это псевдоним для Employees
        JOIN Departments d ON e.DepartmentID = d.DepartmentID; -- 'd' это псевдоним для Departments
        ```

*   **Условия (`WHERE` и `HAVING`):**
    Логические выражения, используемые для фильтрации данных.
    *   **`WHERE` clause:**
        *   Фильтрует строки из таблиц, указанных в `FROM`, **до** какой-либо группировки.
        *   Не может содержать агрегатные функции.
        *   **Операторы в условиях `WHERE` (и `HAVING`):**
            *   Сравнения: `=`, `!=` (или `<>`), `<`, `>`, `<=`, `>=`
            *   Логические: `AND`, `OR`, `NOT`
            *   `BETWEEN value1 AND value2`: Проверка на вхождение в диапазон (включая границы).
            *   `IN (value1, value2, ...)`: Проверка на вхождение в список значений.
            *   `LIKE 'pattern'`: Поиск по шаблону.
                *   `%`: Соответствует любой строке из нуля или более символов.
                *   `_`: Соответствует любому одиночному символу.
                *   `ESCAPE 'char'`: Для экранирования символов `%` и `_`, если их нужно искать как обычные символы.
            *   `IS NULL`, `IS NOT NULL`: Проверка на наличие или отсутствие NULL-значения.
            *   Можно использовать подзапросы, возвращающие одно значение или список значений.
        *   Пример:
            ```sql
            SELECT * FROM Orders
            WHERE (OrderDate BETWEEN '2023-01-01' AND '2023-06-30')
              AND ShipCity = 'London'
              AND CustomerID IN (SELECT CustomerID FROM Customers WHERE Country = 'UK');
            ```
    *   **`HAVING` clause:**
        *   Фильтрует группы, созданные предложением `GROUP BY`, **после** группировки и агрегации.
        *   Может содержать агрегатные функции.
        *   Использует те же операторы, что и `WHERE`.
        *   Пример:
            ```sql
            SELECT CategoryID, AVG(UnitPrice) AS AveragePrice
            FROM Products
            GROUP BY CategoryID
            HAVING AVG(UnitPrice) > 50 AND COUNT(*) > 3;
            -- Выбрать категории, где средняя цена продукта больше 50 и количество продуктов в категории больше 3.
            ```

---

**Практическая часть**

**1. Задачи с использованием SELECT, CREATE, ALTER, DROP**

Здесь вам нужно будет продемонстрировать умение писать SQL-запросы.

*   **`CREATE`:**
    *   **Задача:** Создать таблицу `Students` с полями: `StudentID` (целое число, первичный ключ), `FirstName` (строка до 50 символов, не NULL), `LastName` (строка до 50 символов, не NULL), `BirthDate` (дата), `GroupID` (целое число).
    *   **Решение (пример для PostgreSQL/стандарт SQL):**
        ```sql
        CREATE TABLE Students (
            StudentID INT PRIMARY KEY,
            FirstName VARCHAR(50) NOT NULL,
            LastName VARCHAR(50) NOT NULL,
            BirthDate DATE,
            GroupID INT
        );
        ```
    *   **Задача:** Создать таблицу `Groups` с полями: `GroupID` (целое число, первичный ключ), `GroupName` (строка до 30 символов, уникальное, не NULL). Добавить внешний ключ в таблицу `Students` для поля `GroupID`, ссылающийся на `Groups.GroupID`.
    *   **Решение:**
        ```sql
        CREATE TABLE Groups (
            GroupID INT PRIMARY KEY,
            GroupName VARCHAR(30) NOT NULL UNIQUE
        );

        ALTER TABLE Students
        ADD CONSTRAINT FK_Students_Groups FOREIGN KEY (GroupID) REFERENCES Groups(GroupID);
        ```
        (Или можно было определить FK сразу при создании `Students`, если `Groups` уже существует).

*   **`ALTER`:**
    *   **Задача:** В таблицу `Students` добавить столбец `Email` (строка до 100 символов).
    *   **Решение:**
        ```sql
        ALTER TABLE Students
        ADD COLUMN Email VARCHAR(100);
        ```
    *   **Задача:** Сделать столбец `Email` в таблице `Students` уникальным.
    *   **Решение:**
        ```sql
        ALTER TABLE Students
        ADD CONSTRAINT UQ_Students_Email UNIQUE (Email);
        ```
    *   **Задача:** Изменить тип столбца `GroupName` в таблице `Groups` на `VARCHAR(50)`.
    *   **Решение (PostgreSQL):**
        ```sql
        ALTER TABLE Groups
        ALTER COLUMN GroupName TYPE VARCHAR(50);
        ```
        **(MySQL):** `ALTER TABLE Groups MODIFY COLUMN GroupName VARCHAR(50);`
        **(SQL Server):** `ALTER TABLE Groups ALTER COLUMN GroupName VARCHAR(50);`

*   **`DROP`:**
    *   **Задача:** Удалить ограничение уникальности `UQ_Students_Email` из таблицы `Students`.
    *   **Решение (синтаксис может немного отличаться):**
        ```sql
        ALTER TABLE Students
        DROP CONSTRAINT UQ_Students_Email;
        ```
    *   **Задача:** Удалить столбец `BirthDate` из таблицы `Students`.
    *   **Решение:**
        ```sql
        ALTER TABLE Students
        DROP COLUMN BirthDate;
        ```
    *   **Задача:** Удалить таблицу `Students`. (Убедитесь, что это учебная задача, не на рабочей БД!).
    *   **Решение:**
        ```sql
        DROP TABLE Students;
        ```
        (Если есть внешние ключи, ссылающиеся на `Students` из других таблиц, сначала нужно удалить их, либо использовать `DROP TABLE Students CASCADE;` – с осторожностью!)

*   **`SELECT`:**
    *   **Задача:** Выбрать имена и фамилии всех студентов.
    *   **Решение:** `SELECT FirstName, LastName FROM Students;`
    *   **Задача:** Выбрать всех студентов из группы с `GroupID = 101`.
    *   **Решение:** `SELECT * FROM Students WHERE GroupID = 101;`
    *   **Задача:** Выбрать студентов, чья фамилия начинается на "Иванов".
    *   **Решение:** `SELECT * FROM Students WHERE LastName LIKE 'Иванов%';`
    *   **Задача:** Подсчитать количество студентов в каждой группе. Вывести `GroupID` и количество.
    *   **Решение:** `SELECT GroupID, COUNT(*) AS NumberOfStudents FROM Students GROUP BY GroupID;`
    *   **Задача:** Выбрать имена студентов и названия их групп.
    *   **Решение:**
        ```sql
        SELECT s.FirstName, s.LastName, g.GroupName
        FROM Students s
        JOIN Groups g ON s.GroupID = g.GroupID;
        ```
    *   **Задача:** Выбрать 5 самых молодых студентов.
    *   **Решение (если `BirthDate` есть):**
        ```sql
        -- SELECT FirstName, LastName, BirthDate
        -- FROM Students
        -- ORDER BY BirthDate DESC
        -- LIMIT 5; -- (PostgreSQL/MySQL)
        ```
        (Если BirthDate удалили, задача теряет смысл или нужна другая логика)

**2. Нормализация.**

Здесь вам, скорее всего, дадут одну большую "плоскую" таблицу и попросят нормализовать её до 3НФ.

**Пример:**
Дана таблица `Заказы_Клиентов`:
`ЗаказID (PK), ДатаЗаказа, КлиентID, ФИОКлиента, ТелефонКлиента, АдресКлиента, ТоварID, НазваниеТовара, ЦенаТовара, Количество, СуммаСтроки`

**Шаг 1: Приведение к 1НФ**
*   Все атрибуты атомарны? Да.
*   Есть первичный ключ? Да, `ЗаказID` (но он идентифицирует заказ, а не строку этой таблицы, если один заказ может содержать много товаров). Если `(ЗаказID, ТоварID)` является ключом для строки, то он составной. Предположим, что `(ЗаказID, ТоварID)` - это первичный ключ для каждой строки товарной позиции в заказе.

**Исходная таблица (УНФ - условно-нормальная форма, или уже 1НФ, если все атрибуты атомарны):**
`ЗаказыКлиентов (<u>ЗаказID</u>, <u>ТоварID</u>, ДатаЗаказа, КлиентID, ФИОКлиента, ТелефонКлиента, АдресКлиента, НазваниеТовара, ЦенаТовара, Количество, СуммаСтроки)`

**Шаг 2: Приведение к 2НФ (устранение частичных зависимостей)**
Первичный ключ у нас составной: `(ЗаказID, ТоварID)`.
Ищем атрибуты, которые зависят только от части ключа.
*   `ЗаказID` → `ДатаЗаказа`, `КлиентID`, `ФИОКлиента`, `ТелефонКлиента`, `АдресКлиента` (эти атрибуты зависят только от `ЗаказID`, а не от `ТоварID` в заказе). Это частичная зависимость.
*   `ТоварID` → `НазваниеТовара`, `ЦенаТовара` (эти атрибуты зависят только от `ТоварID`, а не от `ЗаказID`). Это частичная зависимость.
*   `(ЗаказID, ТоварID)` → `Количество`, `СуммаСтроки` (эти зависят от полного ключа).

**Декомпозиция для 2НФ:**
1.  `Заказы (<u>ЗаказID</u>, ДатаЗаказа, КлиентID, ФИОКлиента, ТелефонКлиента, АдресКлиента)`
2.  `Товары (<u>ТоварID</u>, НазваниеТовара, ЦенаТовара)`
3.  `СоставЗаказа (<u>ЗаказID (FK)</u>, <u>ТоварID (FK)</u>, Количество, СуммаСтроки)`

**Шаг 3: Приведение к 3НФ (устранение транзитивных зависимостей)**
Анализируем полученные таблицы на транзитивные зависимости (когда неключевой атрибут зависит от другого неключевого атрибута).

*   **Таблица `Товары`:** `ТоварID` → `НазваниеТовара`, `ТоварID` → `ЦенаТовара`. Нет транзитивных зависимостей. (В 3НФ)
*   **Таблица `СоставЗаказа`:** `(ЗаказID, ТоварID)` → `Количество`, `(ЗаказID, ТоварID)` → `СуммаСтроки`. (Примечание: `СуммаСтроки` может быть вычисляемой (`ЦенаТовара * Количество`), если `ЦенаТовара` брать из таблицы `Товары` на момент заказа, или храниться как историческая. Если `ЦенаТовара` из `Товары` может меняться, то в `СоставЗаказа` лучше хранить цену на момент продажи. Для простоты допустим, что `СуммаСтроки` зависит от ключа). Нет транзитивных зависимостей. (В 3НФ)
*   **Таблица `Заказы`:**
    `ЗаказID (PK), ДатаЗаказа, КлиентID, ФИОКлиента, ТелефонКлиента, АдресКлиента`
    Здесь есть зависимость: `КлиентID` → `ФИОКлиента`, `ТелефонКлиента`, `АдресКлиента`.
    А поскольку `ЗаказID` → `КлиентID`, то имеем транзитивные зависимости:
    `ЗаказID` → `КлиентID` → `ФИОКлиента`
    `ЗаказID` → `КлиентID` → `ТелефонКлиента`
    `ЗаказID` → `КлиентID` → `АдресКлиента`

**Декомпозиция таблицы `Заказы` для 3НФ:**
1.  `Клиенты (<u>КлиентID</u>, ФИОКлиента, ТелефонКлиента, АдресКлиента)`
2.  `Заказы_Новая (<u>ЗаказID</u>, ДатаЗаказа, КлиентID (FK))`

**Итоговые таблицы в 3НФ:**
1.  **`Клиенты`** `(<u>КлиентID</u>, ФИОКлиента, ТелефонКлиента, АдресКлиента)`
2.  **`Товары`** `(<u>ТоварID</u>, НазваниеТовара, ЦенаТовара)`
3.  **`Заказы`** `(<u>ЗаказID</u>, ДатаЗаказа, КлиентID (FK))`
4.  **`СоставЗаказа`** `(<u>ЗаказID (FK)</u>, <u>ТоварID (FK)</u>, Количество, СуммаСтроки)`
    (В `СоставЗаказа` можно добавить `ЦенаПродажи` если цена товара может меняться, а в заказе нужно зафиксировать цену на момент продажи).

На экзамене вам нужно будет объяснить каждый шаг, идентифицировать функциональные зависимости и показать, как вы декомпозируете таблицы.

---

Удачи на экзамене! Если проработать все эти пункты с пониманием, вы будете хорошо подготовлены.Отлично! Это подробный и хорошо структурированный материал для подготовки. Давайте пройдемся по каждому вопросу.

**Теоретическая часть:**

**1. Недостатки плоских файлов и пути их преодоления.**
*   **Плоские файлы:** Данные хранятся в виде простых текстовых файлов (CSV, TXT) или бинарных файлов с простой структурой. Каждая строка – запись, поля разделены или имеют фиксированную длину.
*   **Недостатки:**
    1.  **Избыточность данных:** Дублирование информации (например, адрес клиента в каждом заказе).
    2.  **Противоречивость данных:** Из-за избыточности, обновление в одном месте может не отразиться в другом.
    3.  **Трудность доступа к данным:** Нет стандартного языка запросов, нужны специальные программы для чтения/поиска.
    4.  **Проблемы целостности:** Сложно обеспечить выполнение правил для данных (типы, диапазоны, связи).
    5.  **Проблемы параллельного доступа:** Несколько пользователей не могут эффективно работать одновременно.
    6.  **Проблемы безопасности:** Сложно разграничить права доступа.
    7.  **Зависимость данных от приложений:** Формат данных жестко связан с программой, его обрабатывающей.
*   **Пути преодоления:** Использование **Систем Управления Базами Данных (СУБД)**, которые предоставляют:
    *   Структурированное хранение (модели данных).
    *   Устранение избыточности (нормализация).
    *   Обеспечение целостности (ограничения).
    *   Язык запросов (SQL).
    *   Управление параллельным доступом (транзакции, блокировки).
    *   Безопасность (права доступа).
    *   Независимость данных.

**2. Модели данных. Иерархическая, сетевая и реляционная модели данных.**
*   **Модель данных:** Способ представления данных, их связей, семантики и ограничений.
*   **Иерархическая:**
    *   Структура "дерево" (родитель -> много потомков, у потомка один родитель).
    *   Связи 1:N.
    *   Пример: файловая система.
    *   Плюсы: простота для иерархий, быстрый доступ по связям.
    *   Минусы: избыточность для M:N, сложность изменения структуры.
*   **Сетевая:**
    *   Структура "граф" (запись может иметь много "родителей" и много "потомков").
    *   Позволяет M:N связи.
    *   Пример: студенты и курсы.
    *   Плюсы: гибче иерархической, меньше избыточности для M:N.
    *   Минусы: сложность проектирования, навигационный доступ.
*   **Реляционная:**
    *   Данные в виде таблиц (отношений). Таблицы из строк (кортежей) и столбцов (атрибутов).
    *   Связи через общие значения в столбцах (внешние ключи).
    *   Пример: MySQL, PostgreSQL.
    *   Плюсы: гибкость, простота, мат. основа, SQL.
    *   Минусы: может быть медленнее для специфических навигационных запросов без должной оптимизации.

**3. Реляционная модель данных. 12 правил Кодда.**
*   **Реляционная модель:** (см. выше). Ключевые понятия: отношение, атрибут, кортеж, домен, первичный ключ, внешний ключ.
*   **12 правил Кодда (основная суть):** Определяют "истинно" реляционную СУБД.
    1.  **Информационное правило:** Все данные – значения в таблицах.
    2.  **Гарантированный доступ:** Доступ к любому значению по имени таблицы, столбца и первичному ключу.
    3.  **Обработка NULL:** Систематическая поддержка NULL для отсутствующей/неприменимой информации.
    4.  **Онлайн-каталог:** Метаданные (описание БД) доступны тем же языком, что и данные.
    5.  **Всеобъемлющий подъязык:** Мощный язык для всех операций (определение, манипулирование, целостность, права, транзакции). (SQL подходит).
    6.  **Обновление представлений:** Обновляемые представления должны быть обновляемы системой.
    7.  **Высокоуровневые операции:** Вставка, обновление, удаление работают с наборами строк.
    8.  **Физическая независимость:** Изменения в физическом хранении не влияют на приложения.
    9.  **Логическая независимость:** Изменения в логической структуре (не затрагивающие видимые данные) не влияют на приложения.
    10. **Независимость целостности:** Ограничения хранятся в каталоге, а не в приложениях.
    11. **Независимость распределения:** Распределение данных по сети не должно быть видно пользователю.
    12. **Запрет обхода правил:** Низкоуровневый доступ не должен позволять обходить высокоуровневые правила целостности.

**4. Представление и манипулирование данными. Ограничения целостности. Каскадные операции.**
*   **Представление:** Таблицы, строки, столбцы.
*   **Манипулирование:** SQL DML (SELECT, INSERT, UPDATE, DELETE).
*   **Ограничения целостности:**
    *   **Entity Integrity (целостность сущностей):** PK не NULL и уникален (`PRIMARY KEY`).
    *   **Referential Integrity (ссылочная целостность):** FK должен ссылаться на существующий PK или быть NULL (`FOREIGN KEY`).
    *   **Domain Integrity (целостность доменов):** Значения в столбце соответствуют типу и формату (`CREATE TABLE ... тип_данных`, `CHECK`).
    *   **User-defined Integrity (пользовательская):** Специфические бизнес-правила (`CHECK`, триггеры).
*   **Каскадные операции (для FK):**
    *   `ON DELETE CASCADE`: При удалении родительской записи удаляются связанные дочерние.
    *   `ON UPDATE CASCADE`: При обновлении PK родителя обновляются FK в дочерних.
    *   Другие: `SET NULL`, `SET DEFAULT`, `RESTRICT`, `NO ACTION`.

**5. Язык манипулирования для реляционной модели данных. Реляционная алгебра.**
*   **Реляционная алгебра:** Формальный процедурный язык запросов. Операнды и результат – отношения.
*   **Основные операции:**
    *   **Выборка (σ, SELECTION):** `σ_{условие}(R)` – выбирает строки.
    *   **Проекция (π, PROJECTION):** `π_{атрибуты}(R)` – выбирает столбцы (убирает дубли).
    *   **Объединение (∪, UNION):** `R ∪ S` – все строки из R и S (убирает дубли, требует совместимости).
    *   **Разность (–, DIFFERENCE):** `R – S` – строки из R, которых нет в S (требует совместимости).
    *   **Декартово произведение (×, CARTESIAN PRODUCT):** `R × S` – все комбинации строк.
    *   **Переименование (ρ, RENAME):** `ρ_{НовоеИмя}(R)` – меняет имя отношения/атрибутов.
*   **Производные:** Пересечение (∩), Соединение (⋈), Деление (÷).

**6. Реляционные операции и правила их выполнения.**
*   См. пункт 5.
*   **Правила:**
    *   **Замкнутость:** Результат операции – всегда отношение.
    *   **Совместимость по типам:** Для ∪, –, ∩ нужно одинаковое число атрибутов и совместимые типы.
    *   **Порядок не важен:** Порядок строк и столбцов в отношении не имеет значения.
    *   **Дубликаты:** В теории отсутствуют (отношение – множество).

**7. Типы запросов и их представление в реляционной алгебре.**
*   **Простая выборка:** `σ_{условие}(Таблица)`
*   **Проекция:** `π_{столбец1, столбец2}(Таблица)`
*   **Выборка + Проекция:** `π_{столбцы}(σ_{условие}(Таблица))`
*   **Соединение:** `Таблица1 ⋈_{условие_соединения} Таблица2`
    *   Естественное соединение: `Таблица1 ⋈ Таблица2` (по одноименным столбцам).
*   **Пример:** "Имена студентов, сдавших 'Математику' на оценку > 3"
    `π_{ИмяСтудента}(Студенты ⋈ (σ_{Предмет='Математика' ∧ Оценка>3}(Оценки)))` (если Оценки содержат ID студента).

**8. Свойства реляционных операций.**
*   **Коммутативность:** `A ∪ B = B ∪ A`, `A ⋈ B = B ⋈ A` (для естественного).
*   **Ассоциативность:** `(A ∪ B) ∪ C = A ∪ (B ∪ C)`.
*   **Дистрибутивность:** `σ_{P}(A ∪ B) = σ_{P}(A) ∪ σ_{P}(B)`.
*   **Каскадирование выборок:** `σ_{P1}(σ_{P2}(R)) = σ_{P1 ∧ P2}(R)`.
*   **Перестановка выборки и проекции:** `π_{A}(σ_{P}(R)) = σ_{P}(π_{A}(R))` (если P использует только атрибуты из A).
*   **Важность:** Используются оптимизаторами запросов для построения эффективных планов выполнения.

**9. Проектирование реляционной базы данных с помощью нормализации.**
*   **Нормализация:** Процесс устранения избыточности и аномалий (вставки, обновления, удаления) путем декомпозиции таблиц.
*   **Функциональная зависимость (ФЗ):** X → Y (Y функционально зависит от X), если каждому значению X соответствует не более одного значения Y.
*   **Нормальные формы:**
    *   **1НФ:** Все атрибуты атомарны (неделимы), есть PK.
    *   **2НФ:** В 1НФ + все неключевые атрибуты полностью зависят от *всего* первичного ключа (нет частичных зависимостей от частей составного PK).
    *   **3НФ:** В 2НФ + нет транзитивных зависимостей (неключевой атрибут не зависит от другого неключевого атрибута).
    *   **НФБК (BCNF):** Более строгая 3НФ. Для каждой нетривиальной ФЗ X → Y, X должен быть суперключом.
*   **Цель:** Достичь обычно 3НФ или НФБК.

**10. Язык SQL. Описание данных. Константы. Переменные. Функции. Выражения. Условия.**
*   **SQL:** Язык для работы с реляционными БД. DDL, DML, DCL, TCL.
*   **Описание данных (DDL):** `CREATE TABLE`, `ALTER TABLE`, `DROP TABLE`. Типы данных: `INT`, `VARCHAR`, `DATE`, etc.
*   **Константы (литералы):** `123`, `'text'`, `'2023-01-01'`, `TRUE`, `NULL`.
*   **Переменные:** В диалектах SQL (T-SQL: `@var`, PL/pgSQL: `DECLARE var`).
*   **Функции:**
    *   **Встроенные:**
        *   Агрегатные: `COUNT`, `SUM`, `AVG`, `MIN`, `MAX`.
        *   Скалярные: `UPPER`, `LOWER`, `SUBSTRING`, `NOW()`, `ROUND`.
    *   **Пользовательские (UDF):** Создаются пользователем.
*   **Выражения:** Комбинации констант, столбцов, операторов, функций ( `Salary * 1.1`, `FirstName || ' ' || LastName`).
*   **Условия (в `WHERE`, `HAVING`, `ON`):** Логические выражения. Операторы: `=`, `<`, `>`, `AND`, `OR`, `NOT`, `LIKE`, `IN`, `BETWEEN`, `IS NULL`.

**11. Язык SQL. Манипулирование данными.**
*   **DML (Data Manipulation Language):**
    *   `SELECT ... FROM ... WHERE ...;` (Извлечение)
    *   `INSERT INTO ... (column_list) VALUES (value_list);` (Добавление)
    *   `UPDATE ... SET column = value WHERE ...;` (Изменение)
    *   `DELETE FROM ... WHERE ...;` (Удаление)

**12. Типы запросов и их представление в SQL.**
*   **Простая выборка:** `SELECT * FROM Table;`
*   **Проекция:** `SELECT Col1, Col2 FROM Table;`
*   **Условие:** `SELECT ... WHERE Condition;`
*   **Сортировка:** `SELECT ... ORDER BY Col ASC/DESC;`
*   **Группировка:** `SELECT ColGroup, COUNT(*) FROM Table GROUP BY ColGroup;`
*   **Условие на группы:** `SELECT ... GROUP BY ... HAVING ConditionOnAggregates;`
*   **Соединения:** `INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN`, `FULL JOIN`.
*   **Подзапросы:** В `SELECT`, `FROM`, `WHERE`.
*   **Операции над множествами:** `UNION`, `UNION ALL`, `INTERSECT`, `EXCEPT`.

**13. Транзакции и их реализация в разных системах.**
*   **Транзакция:** Логическая единица работы (все или ничего).
*   **ACID свойства:**
    *   **Atomicity (Атомарность):** Либо все операции выполнены, либо ни одной.
    *   **Consistency (Согласованность):** БД переходит из одного согласованного состояния в другое.
    *   **Isolation (Изоляция):** Параллельные транзакции не влияют друг на друга (как если бы выполнялись последовательно).
    *   **Durability (Долговечность):** Результаты зафиксированной транзакции сохраняются даже при сбоях.
*   **SQL команды:** `BEGIN TRANSACTION`, `COMMIT`, `ROLLBACK`, `SAVEPOINT`.
*   **Реализация:**
    *   **Журналирование (Logging, WAL):** Запись изменений в лог-файл для отката/наката.
    *   **Блокировки (Locking):** Shared (S), Exclusive (X) locks на ресурсы.
    *   **MVCC (Multiversion Concurrency Control):** Создание версий данных, "читатели не блокируют писателей".
    *   **Уровни изоляции:** `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE`.

**14. Динамический SQL и хранимые процедуры.**
*   **Динамический SQL:** SQL-запросы, формируемые и выполняемые программой во время её работы (runtime).
    *   `EXEC('...')`, `sp_executesql` (SQL Server), `EXECUTE IMMEDIATE` (Oracle).
    *   Плюсы: гибкость.
    *   Минусы: риск SQL-инъекций (!!!), сложность, производительность (если не параметризован).
*   **Хранимые процедуры:** Именованный блок SQL-кода, хранящийся в БД.
    *   `CREATE PROCEDURE ... AS BEGIN ... END;`
    *   Плюсы: производительность (скомпилированный план), уменьшение трафика, повторное использование, безопасность (права на процедуру), централизация логики.
    *   Минусы: переносимость (диалекты), сложность отладки.

**15. Хранимые процедуры и триггеры.**
*   **Хранимые процедуры:** (см. выше). Вызываются явно.
*   **Триггеры:** Специальные хранимые процедуры, выполняемые **автоматически** в ответ на события DML (`INSERT`, `UPDATE`, `DELETE`) в таблице или DDL.
    *   `CREATE TRIGGER ... ON Table FOR/AFTER/INSTEAD OF INSERT, UPDATE, DELETE AS ...`
    *   `BEFORE` / `AFTER` / `INSTEAD OF`.
    *   `FOR EACH ROW` / `FOR EACH STATEMENT`.
    *   Доступ к `NEW`/`OLD` (PostgreSQL, Oracle) или `inserted`/`deleted` (SQL Server) псевдо-таблицам.
    *   Применение: аудит, сложная целостность, каскадные обновления.
    *   Минусы: "скрытая" логика, производительность, сложность отладки каскадных триггеров.

**16. Коллективный доступ к базе данных.**
*   **Проблемы (аномалии):**
    *   **Lost Update (Потерянное обновление):** Две транзакции изменяют одни данные, одна перезаписывает другую.
    *   **Dirty Read ("Грязное" чтение):** Чтение не зафиксированных данных другой транзакции.
    *   **Non-repeatable Read (Неповторяющееся чтение):** Повторное чтение тех же данных дает разный результат из-за изменений другой транзакцией.
    *   **Phantom Read (Фантомное чтение):** Повторный запрос с тем же условием дает новые строки из-за вставки другой транзакцией.
*   **Механизмы управления:** Блокировки, MVCC, временные метки, уровни изоляции (см. вопрос 13).
*   **Deadlocks (Взаимоблокировки):** Две или более транзакции ждут ресурсов, захваченных друг другом. СУБД обнаруживает и разрешает (откатывая одну).

**17. Архитектура банков данных.**
*   **Банк данных (Data Bank):** Обычно синоним СУБД или информационной системы на её основе.
*   **Трехуровневая архитектура ANSI-SPARC (см. вопрос 20):** Внешний, концептуальный, внутренний уровни.
*   **Компоненты СУБД:**
    *   Процессор запросов (парсер, оптимизатор, исполнитель).
    *   Менеджер данных (буферный менеджер, файловый менеджер, менеджер транзакций, логов, блокировок).
*   **Модели развертывания:**
    *   Централизованная.
    *   Клиент-серверная (2-уровневая, 3/N-уровневая).
    *   Распределенная СУБД.
    *   Облачные СУБД (DBaaS).
*   Если речь о **Хранилище Данных (DWH):** Источники -> ETL -> DWH (схемы "звезда"/"снежинка") -> Витрины данных -> BI-инструменты.

**18. Использование внутреннего и внешнего соединения.**
*   **`INNER JOIN` (Внутреннее):**
    *   `SELECT ... FROM T1 INNER JOIN T2 ON T1.key = T2.key;`
    *   Возвращает строки только при совпадении в обеих таблицах.
*   **`LEFT OUTER JOIN` (Левое внешнее) / `LEFT JOIN`:**
    *   `SELECT ... FROM T1 LEFT JOIN T2 ON T1.key = T2.key;`
    *   Все строки из левой таблицы (T1) + совпадения из правой (T2). Если нет совпадения, столбцы T2 будут NULL.
*   **`RIGHT OUTER JOIN` (Правое внешнее) / `RIGHT JOIN`:**
    *   `SELECT ... FROM T1 RIGHT JOIN T2 ON T1.key = T2.key;`
    *   Все строки из правой таблицы (T2) + совпадения из левой (T1). Если нет совпадения, столбцы T1 будут NULL.
*   **`FULL OUTER JOIN` (Полное внешнее) / `FULL JOIN`:**
    *   `SELECT ... FROM T1 FULL JOIN T2 ON T1.key = T2.key;`
    *   Все строки из обеих таблиц. Если нет совпадения, соответствующие столбцы другой таблицы будут NULL.

**19. Представления (view) и работа с ними.**
*   **Представление (View):** Виртуальная таблица, основанная на сохраненном `SELECT`-запросе. Не хранит данные (кроме материализованных).
*   `CREATE VIEW view_name AS SELECT ...;`
*   **Работа:**
    *   `SELECT * FROM view_name;`
    *   Обновление (INSERT, UPDATE, DELETE) через представления возможно, если они "обновляемы" (одна базовая таблица, нет агрегатов, `GROUP BY`, `DISTINCT` и т.д.).
    *   `INSTEAD OF` триггеры для обновления не обновляемых представлений.
*   **Преимущества:** Упрощение запросов, безопасность (скрытие столбцов/строк), логическая независимость данных.

**20. Уровни представления данных (Трехуровневая модель представления данных.). Понятие схемы и подсхемы. Схема отношения.**
*   **Трехуровневая модель ANSI-SPARC:**
    1.  **Внешний уровень (External/View Level):** Как видят БД отдельные пользователи/приложения (несколько **подсхем** / `VIEW`).
    2.  **Концептуальный уровень (Conceptual/Logical Level):** Полная логическая структура БД (**концептуальная схема** / **схема**). Описывает сущности, атрибуты, связи.
    3.  **Внутренний уровень (Internal/Physical Level):** Физическое хранение данных (файлы, индексы) (**внутренняя схема**).
*   **Схема:** Описание структуры БД. Чаще всего = концептуальная схема.
*   **Подсхема:** Внешняя схема, представление части БД для пользователя.
*   **Схема отношения:** Имя отношения + список его атрибутов и их доменов. `TableName(Col1:Type1, Col2:Type2, ...)`.

**21. Нотация Мартина. Нотация П.Чена.**
*   **ER-диаграммы (Entity-Relationship Diagrams).**
*   **Нотация П.Чена:**
    *   Сущность: Прямоугольник.
    *   Атрибут: Овал (ключевой - подчеркнут).
    *   Связь: Ромб.
    *   Кардинальность: 1, N, M на линиях к ромбу.
*   **Нотация Мартина (Information Engineering / Crow's Foot):**
    *   Сущность: Прямоугольник (атрибуты внутри).
    *   Связь: Линия между сущностями.
    *   Кардинальность/Модальность: Символы на концах линии:
        *   `|` (один), `o` (ноль), `>-` ("куриная лапка" - много).
        *   Комбинации: `|-|` (один-обязательно), `o-|` (ноль-или-один), `|->-` (один-ко-многим-обязательно), `o->-` (ноль-ко-многим).

**22. Предложения SQL. Сортировка. Группировка. Условие в группировке. Функции;**
*   **Сортировка (`ORDER BY`):** `ORDER BY column [ASC|DESC], ...;` (в конце запроса).
*   **Группировка (`GROUP BY`):** `GROUP BY column1, column2, ...;` Используется с агрегатными функциями.
*   **Агрегатные функции:** `COUNT()`, `SUM()`, `AVG()`, `MIN()`, `MAX()`.
*   **Условие в группировке (`HAVING`):** `HAVING aggregate_function_condition;` Фильтрует группы *после* группировки. ( `WHERE` фильтрует строки *до* группировки).
*   **Логический порядок выполнения SELECT:** `FROM` -> `WHERE` -> `GROUP BY` -> `HAVING` -> `SELECT` (выражения) -> `DISTINCT` -> `ORDER BY` -> `LIMIT/TOP`.

**23. Язык определения данных. Предложения CREATE, ALTER, DROP. Приведите пример использования каждого предложения;**
*   **DDL (Data Definition Language):**
*   **`CREATE`:**
    *   `CREATE DATABASE db_name;`
    *   `CREATE TABLE table_name (col1 TYPE1 CONSTRAINTS, col2 TYPE2 ...);`
        *   Пример: `CREATE TABLE Employees (ID INT PRIMARY KEY, Name VARCHAR(100) NOT NULL, Salary DECIMAL(10,2) CHECK (Salary > 0));`
    *   `CREATE INDEX idx_name ON table_name (column);`
    *   `CREATE VIEW view_name AS SELECT ...;`
*   **`ALTER`:**
    *   `ALTER TABLE table_name ADD COLUMN col_new TYPE;`
        *   Пример: `ALTER TABLE Employees ADD COLUMN DepartmentID INT;`
    *   `ALTER TABLE table_name DROP COLUMN col_name;`
    *   `ALTER TABLE table_name MODIFY COLUMN col_name NEW_TYPE;` (MySQL) / `ALTER COLUMN col_name TYPE NEW_TYPE;` (PostgreSQL) / `ALTER COLUMN col_name NEW_TYPE;` (SQL Server)
    *   `ALTER TABLE table_name ADD CONSTRAINT const_name TYPE (details);`
        *   Пример: `ALTER TABLE Employees ADD CONSTRAINT FK_Emp_Dept FOREIGN KEY (DepartmentID) REFERENCES Departments(ID);`
*   **`DROP`:**
    *   `DROP TABLE table_name;`
        *   Пример: `DROP TABLE OldEmployees;`
    *   `DROP DATABASE db_name;`
    *   `DROP INDEX idx_name ON table_name;`

**24. Предложения SQL. Выборка. Виды выборки. Псевдонимы. Условия**
*   **Выборка (`SELECT`):**
    *   **Виды:**
        *   Все столбцы, все строки: `SELECT * FROM table;`
        *   Определенные столбцы (проекция): `SELECT col1, col2 FROM table;`
        *   С условием (`WHERE`): `SELECT ... WHERE condition;`
        *   С уникальными значениями (`DISTINCT`): `SELECT DISTINCT col FROM table;`
        *   С вычисляемыми полями: `SELECT col1, col2 * 1.1 AS new_col FROM table;`
        *   С агрегацией (`GROUP BY`): `SELECT group_col, COUNT(*) FROM table GROUP BY group_col;`
        *   Из нескольких таблиц (`JOIN`): `SELECT ... FROM t1 JOIN t2 ON ...;`
*   **Псевдонимы (Aliases):**
    *   Для столбцов: `SELECT column_name AS alias_name ...` ( `AS` опционально).
    *   Для таблиц: `SELECT t1.col FROM table_name t1 ...` ( `AS` обычно опускают).
    *   Использование: читаемость, сокращение, различение одинаковых имен, self-join.
*   **Условия (`WHERE`, `HAVING`):**
    *   `WHERE`: фильтрация строк до группировки.
    *   `HAVING`: фильтрация групп после группировки.
    *   Операторы: `=`, `<`, `>`, `AND`, `OR`, `NOT`, `LIKE` (`%`, `_`), `IN`, `BETWEEN`, `IS NULL`.

**Практическая часть**

**1. Задачи с использованием SELECT, CREATE, ALTER, DROP**
*   **`CREATE TABLE`:** Создайте таблицу `Products` (ProductID INT PK, ProductName VARCHAR(100) NOT NULL, Price DECIMAL(10,2), CategoryID INT).
*   **`ALTER TABLE`:** Добавьте в `Products` столбец `SupplierID INT`. Добавьте FK на `CategoryID` к таблице `Categories` (предполагается, что она есть).
*   **`INSERT INTO`:** Вставьте несколько записей в `Products`.
*   **`SELECT`:**
    *   Выбрать все товары дороже 100.
    *   Выбрать названия товаров и их категорий (потребуется JOIN с таблицей `Categories`).
    *   Подсчитать количество товаров в каждой категории.
    *   Выбрать товары с `ProductName` содержащим слово "Молоко".
*   **`UPDATE`:** Увеличить цену всех товаров в категории с `CategoryID=1` на 10%.
*   **`DELETE`:** Удалить товары с `Price < 10`.
*   **`DROP TABLE`:** Удалить тестовую таблицу (если создавали для эксперимента).

**2. Нормализация.**
*   **Задача:** Дана таблица `Проекты_Сотрудники (ПроектID, НазваниеПроекта, РуководительПроекта_ФИО, СотрудникID, ФИОСотрудника, ДолжностьСотрудника, ЧасыРаботыНаПроекте)`. Нормализовать до 3НФ.
*   **Решение (этапы):**
    1.  **1НФ:** Все атрибуты атомарны. PK, вероятно, `(ПроектID, СотрудникID)`.
    2.  **2НФ (устранение частичных зависимостей):**
        *   `Проекты (<u>ПроектID</u>, НазваниеПроекта, РуководительПроекта_ФИО)`
        *   `Сотрудники (<u>СотрудникID</u>, ФИОСотрудника, ДолжностьСотрудника)`
        *   `РаботаНаПроекте (<u>ПроектID (FK)</u>, <u>СотрудникID (FK)</u>, ЧасыРаботыНаПроекте)`
    3.  **3НФ (устранение транзитивных зависимостей):**
        *   В `Проекты`: `ПроектID -> РуководительПроекта_ФИО`. Если ФИО руководителя зависит от ID руководителя (неключевого атрибута), то нужно вынести в таблицу `Руководители`. Но здесь ФИО руководителя – это просто атрибут проекта. Зависит от того, как интерпретировать "РуководительПроекта_ФИО". Если это просто текстовое поле, то таблица `Проекты` уже в 3НФ. Если есть отдельная сущность "Руководитель", то нужна декомпозиция.
        *   В `Сотрудники`: `СотрудникID -> ДолжностьСотрудника`. Если `ДолжностьСотрудника` влечет за собой другие атрибуты (например, `ОкладДолжности`), то `Должность` нужно вынести в отдельную таблицу. Если `ДолжностьСотрудника` – просто текстовое поле, то `Сотрудники` в 3НФ.
        *   `РаботаНаПроекте` уже в 3НФ.

    **Предполагая, что "РуководительПроекта_ФИО" и "ДолжностьСотрудника" - это просто описательные атрибуты, не влекущие за собой других зависимостей, то результат 2НФ уже будет и 3НФ.**
    Если же мы считаем, что должность определяет, например, ставку, то:
    `Сотрудники (<u>СотрудникID</u>, ФИОСотрудника, ДолжностьID (FK))`
    `Должности (<u>ДолжностьID</u>, НазваниеДолжности, Ставка)`
    Аналогично с руководителем.

Удачи на экзамене! Главное – понимать суть каждого понятия.